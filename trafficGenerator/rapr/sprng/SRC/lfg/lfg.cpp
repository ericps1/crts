/*************************************************************************/
/*************************************************************************/
/* Parallel Modified Additive Lagged Fibonacci Generator                 */
/*                                                                       */ 
/* Modifed by: J. Ren                                                    */
/*             Florida State University                                  */
/*             Email: ren@csit.fsu.edu                                   */
/*                                                                       */
/* Based on the implementation by:                                       */
/*             Ashok Srinivasan,                                         */
/*                                                                       */
/* Based on the Implementation by:                                       */
/*  Steven A. Cuccaro and Daniel V. Pryor,                               */
/*            IDA/Center for Computing Sciences (CCS)                    */
/* E-Mail: cuccaro@super.org      pryor@super.org                        */
/*                                                                       */ 
/* Copyright 1996 September 3, United States Government as Represented   */
/* by the Director, National Security Agency. All rights reserved.       */
/*                                                                       */
/* Disclaimer 1: NCSA expressly disclaims any and all warranties, expressed*/
/* or implied, concerning the enclosed software.  The intent in sharing  */
/* this software is to promote the productive interchange of ideas       */
/* throughout the research community. All software is furnished on an    */
/* "as is" basis. No further updates to this software should be          */
/* expected. Although this may occur, no commitment exists. The authors  */
/* certainly invite your comments as well as the reporting of any bugs.  */
/* NCSA cannot commit that any or all bugs will be fixed.                */
/*                                                                       */
/* Disclaimer 2: CCS expressly disclaims any and all warranties, expressed */
/* or implied, concerning the enclosed software. This software was       */
/* developed at CCS for use in internal research. The intent in sharing  */
/* this software is to promote the productive interchange of ideas       */
/* throughout the research community. All software is furnished on an    */
/* "as is" basis. No further updates to this software should be          */
/* expected. Although this may occur, no commitment exists. The authors  */
/* certainly invite your comments as well as the reporting of any bugs.  */
/* CCS cannot commit that any or all bugs will be fixed.                 */
/*************************************************************************/
/*************************************************************************/

/*************************************************************************/
/*      This version has been modified to use two integer-based additive */
/*      lagged-Fibonacci generators to produce integer, float and double */
/*      values. The lagged-Fibonacci generators each have 31 bits of     */
/*      precision (after the bit fixed by the canonical form of the      */
/*      generator is removed), 31-bit values are generated by XORing     */
/*      the values after one has been shifted left one bit. The floating */
/*      point value is formed by dividing the integer by 1.e+32 (the     */
/*      lsb's will be dropped from the mantissa to make room for the     */
/*      exponent), and two of these integer values in sequence are used  */
/*      to get the necessary precision for the double value.             */
/*                                                                       */
/*      This method has the advantage that the generators pass fairly    */
/*      strict randomness tests, including the Birthday Spacings test    */
/*      that additive lagged-Fibonacci generators are well known to      */
/*      fail. The disadvantage is the additional time needed to do the   */
/*      division explicitly, which was avoided in previous versions.     */
/*      (As the division is by powers of 2, the user might well consider */
/*      making machine-specific versions of this code to insert the bits */
/*      into the appropriate places and avoid the problem entirely.)     */
/*************************************************************************/

#if __GNUC__ > 3
 #include <iostream>
#else
 #include <iostream.h>
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>
#define NDEBUG
#include <assert.h>
#include "sprng.h"
#include "lfg.h"
#include "memory.h"
#include "store.h"

#define gseed lfg_gseed
#define lv lfg_lv
#define kv lfg_kv

#define MAX_STREAMS lfg_MAX_STREAMS
#define NGENS lfg_NEGS
#define valid lfg_valid

/*#define PRINT_GEN*/

/*      BITS_IN_INT_GEN is the log_2 of the modulus of the generator     */
/*           for portability this is set to 32, but can be modified;     */
/*           if modified, make sure INT_MOD_MASK can still be calculated */
#define BITS_IN_INT_GEN 32

/*      INT_MOD_MASK is used to perform modular arithmetic - specifying  */
/*           this value compensates for different sized words on         */
/*           different architectures                                     */
/*      FLT_MULT is used in converting to float and double values; the   */
/*           odd form is due to a compiler glitch on our CM-5, which     */
/*	     caused (0.5/(unsigned)(1<<31)) to be negative.              */
#if (BITS_IN_INT_GEN==32)
#define INT_MOD_MASK 0xffffffff
#define FLT_MULT (0.25/(unsigned)(1<<30))
#else
#define INT_MOD_MASK ((unsigned)(1<<BITS_IN_INT_GEN)-1)
#define FLT_MULT (1.0/(1<<BITS_IN_INT_GEN))
#endif
/*      INT_MASK is used to mask out the part of the generator which     */
/*           is not in the canonical form; it should be                  */
/*           2^{BITS_IN_INT_GEN-1}-1                                     */
#define INT_MASK ((unsigned)INT_MOD_MASK>>1)
/*      MAX_BIT_INT is the largest bit position allowed in the index     */
/*           of the node - it equals BITS_IN_INT_GEN - 2                 */
#define MAX_BIT_INT (BITS_IN_INT_GEN-2)
/*      INTX2_MASK is used in calculation of the node numbers            */
#define INTX2_MASK ((1<<MAX_BIT_INT)-1)
 
/*      RUNUP keeps certain generators from looking too similar in the   */
/*          first few words output                                       */
#define RUNUP (2*BITS_IN_INT_GEN)

/*      GS0 gives a more "random" distribution of generators when the    */
/*      user uses small integers as seeds                                */
#define GS0 0x372f05ac
#define TOOMANY "generator has branched maximum number of times;\nindependence of generators no longer guaranteed"

#define VERSION "00"
/*** Name for Generator ***/
#define GENTYPE VERSION "Additive Lagged Fibonacci Generator"

/*************************************************************************/
/*************************************************************************/
/*                  STRUCTURES AND GLOBAL DATA                           */
/*************************************************************************/
/*************************************************************************/

int MAX_STREAMS=0x7fffffff;

struct vstruct {
      int L;
      int K;
      int LSBS;     /* number of least significant bits that are 1 */
      int first;    /* the first seed whose LSB is 1 */
};

const struct vstruct valid[] = { {1279,861,1,233}, {17,5,1,10}, {31,6,1,2},
{55,24,1,11}, {63,31,1,14}, {127,97,1,21}, {521,353,1,100},
{521,168,1,83}, {607,334,1,166}, {607,273,1,105}, {1279,418,1,208}};

#define NPARAMS 11

int gseed=0,lv=0,kv=0;
int NGENS = 0;



/*************************************************************************/
/*************************************************************************/
/*                    ERROR PRINTING FUNCTION                            */
/*************************************************************************/
/*************************************************************************/

static void errprint(const char *level, const char *routine, const char *error)
{
      fprintf(stderr,"%s from %s: %s\n",level,routine,error);
}

/*************************************************************************/
/*************************************************************************/
/*            ROUTINES USED TO CREATE GENERATOR FILLS                    */
/*************************************************************************/
/*************************************************************************/

/**************************/
/* function bitcnt:       */
/**************************/
static int bitcnt( int x)
{
  unsigned i=0,y;

  for (y=(unsigned)x; y; y &= (y-1) ) 
    i++;

  return(i);
}

/**************************/
/* function advance_reg:  */
/**************************/
static void advance_reg(int *reg_fill)
{
/*      the register steps according to the primitive polynomial         */
/*           (64,4,3,1,0); each call steps register 64 times             */
/*      we use two words to represent the register to allow for integer  */
/*           size of 32 bits                                             */

  const int mask = 0x1b;
  int adv_64[4][2];

  int i,new_fill[2];
  unsigned temp;

  adv_64[0][0] = 0xb0000000;
  adv_64[0][1] = 0x1b;
  adv_64[1][0] = 0x60000000;
  adv_64[1][1] = 0x2d;
  adv_64[2][0] = 0xc0000000;
  adv_64[2][1] = 0x5a;
  adv_64[3][0] = 0x80000000;
  adv_64[3][1] = 0xaf;
  new_fill[1] = new_fill[0] = 0;
  temp = mask<<27;

  for (i=27;i>=0;i--) 
  {
    new_fill[0] = (new_fill[0]<<1) | (1&bitcnt(reg_fill[0]&temp));
    new_fill[1] = (new_fill[1]<<1) | (1&bitcnt(reg_fill[1]&temp));
    temp >>= 1;
  }

  for (i=28;i<32;i++) 
  {
    temp = bitcnt(reg_fill[0]&(mask<<i));
    temp ^= bitcnt(reg_fill[1]&(mask>>(32-i)));
    new_fill[0] |= (1&temp)<<i;
    temp = bitcnt(reg_fill[0]&adv_64[i-28][0]);
    temp ^= bitcnt(reg_fill[1]&adv_64[i-28][1]);
    new_fill[1] |= (1&temp)<<i;
  }

  reg_fill[0] = new_fill[0];
  reg_fill[1] = new_fill[1];
}

/**************************/
/*   function get_fill:   */
/**************************/

static int get_fill(unsigned *n, unsigned *r, int param_local, unsigned seed_local)
{
  int i,j,k,temp[2], length;

  length = valid[param_local].L;
  
/*      initialize the shift register with the node number XORed with    */
/*           the global seed                                             */
/*      fill the shift register with two copies of this number           */
/*           except when equal to zero                                   */
  temp[1] = temp[0] = n[0]^seed_local;

  if (!temp[0])
    temp[0] = GS0;

/*      advance the shift register some                                  */
  advance_reg(temp);
  advance_reg(temp);

/*      the first word in the generator is defined by the 31 LSBs of the */
/*           node number                                                 */
  r[0] = (INT_MASK&n[0])<<1;
/*      the generator is filled with the lower 31 bits of the shift      */
/*           register at each time, shifted up to make room for the bits */
/*           defining the canonical form; the node number is XORed into  */
/*           the fill to make the generators unique                      */
  for (i=1;i<length-1;i++) 
  {
    advance_reg(temp);
    r[i] = (INT_MASK&(temp[0]^n[i]))<<1;
  }
  r[length-1] = 0;
/*      the canonical form for the LSB is instituted here                */
  k = valid[param_local].first + valid[param_local].LSBS;

  for (j=valid[param_local].first;j<k;j++)
    r[j] |= 1;

  return(0);
}

/*************************************************************************/
/*************************************************************************/
/*            SI_DOUBLE: updates index for next spawning                 */
/*************************************************************************/
/*************************************************************************/

static void si_double(unsigned *a,  unsigned *b, int length)
{
  int i;

  if (b[length-2]&(1<<MAX_BIT_INT))
    errprint("WARNING","si_double",TOOMANY);
  a[length-2] = (INTX2_MASK&b[length-2])<<1;

  for (i=length-3;i>=0;i--) 
  {
    if (b[i]&(1<<MAX_BIT_INT)) 
      a[i+1]++;
    a[i] = (INTX2_MASK&b[i])<<1;
  }
}

/*************************************************************************/
/*************************************************************************/
/*            GET_RN: returns generated random number                    */
/*************************************************************************/
/*************************************************************************/

int LFG::get_rn_int()
/*      returns value put into new position                              */
{
  unsigned new_val,*r0_local,*r1_local;
  int hptr_local,lptr,*hp = &hptr;
  int lv, kv;
  
  lv = lval;
  kv = kval;
  r0_local = r0;
  r1_local = r1;
  hptr_local = *hp;
  lptr = hptr_local + kv;
  
  if (lptr>=lv) lptr -= lv;
  
/*    INT_MOD_MASK causes arithmetic to be modular when integer size is  */
/*         different from generator modulus                              */
  
  r0_local[hptr_local] = INT_MOD_MASK&(r0_local[hptr_local] + r0_local[lptr]);
  r1_local[hptr_local] = INT_MOD_MASK&(r1_local[hptr_local] + r1_local[lptr]);
  new_val = (r1_local[hptr_local]&(~1)) ^ (r0_local[hptr_local]>>1);
  
  if (--hptr_local < 0) 
    hptr_local = lv - 1; /* skip an element in the sequence */
    
  if (--lptr < 0) 
    lptr = lv - 1;
    
  r0_local[hptr_local] = INT_MOD_MASK&(r0_local[hptr_local] + r0_local[lptr]);
  r1_local[hptr_local] = INT_MOD_MASK&(r1_local[hptr_local] + r1_local[lptr]);
  *hp = (--hptr_local < 0) ? lv-1 : hptr_local;
  
  return (new_val>>1);
}

float LFG::get_rn_flt()
/*      returns value put into new position                              */
{
  unsigned long new_val; /* this cannot be unsigned int due to a bug in the SGI compiler */
  unsigned  *r0_local,*r1_local;	
  int hptr_local,lptr,*hp = &hptr;
  int lv, kv;
	
  lv = lval;
  kv = kval;
  r0_local = r0;
  r1_local = r1;
  hptr_local = *hp;
  lptr = hptr_local + kv;
  
  if (lptr>=lv) 
    lptr -= lv;

/*    INT_MOD_MASK causes arithmetic to be modular when integer size is  */
/*         different from generator modulus                              */
  r0_local[hptr_local] = INT_MOD_MASK&(r0_local[hptr_local] + r0_local[lptr]);
  r1_local[hptr_local] = INT_MOD_MASK&(r1_local[hptr_local] + r1_local[lptr]);
  new_val = (r1_local[hptr_local]&(~1)) ^ (r0_local[hptr_local]>>1);

  if (--hptr_local < 0) 
    hptr_local = lv - 1; /* skip an element in the sequence */
  
  if (--lptr < 0) 
    lptr = lv - 1;

  r0_local[hptr_local] = INT_MOD_MASK&(r0_local[hptr_local] + r0_local[lptr]);
  r1_local[hptr_local] = INT_MOD_MASK&(r1_local[hptr_local] + r1_local[lptr]);
  
  *hp = (--hptr_local<0) ? lv-1 : hptr_local;

  return (new_val*FLT_MULT);
} 

double LFG::get_rn_dbl()
{
  unsigned *r0_local,*r1_local;
  unsigned long temp1,temp2; /* Due to a bug in the SGI compiler, this should not be unsigned int */
  int hptr_local,lptr,*hp = &hptr;
  double new_val;
  int lv, kv;
	
  lv = lval;
  kv = kval;
  r0_local = r0;
  r1_local = r1;
  hptr_local = *hp;
  lptr = hptr_local + kv;

  if (lptr>=lv) 
    lptr -= lv;

  /*    INT_MOD_MASK causes arithmetic to be modular when integer size is  */
  /*         different from generator modulus                              */

  r0_local[hptr_local] = INT_MOD_MASK&(r0_local[hptr_local] + r0_local[lptr]);
  r1_local[hptr_local] = INT_MOD_MASK&(r1_local[hptr_local] + r1_local[lptr]);
  temp1 = (r1_local[hptr_local]&(~1)) ^ (r0_local[hptr_local]>>1);

  if (--hptr_local < 0) 
    hptr_local = lv - 1;
  
  if (--lptr < 0) 
    lptr = lv - 1;
  
  r0_local[hptr_local] = INT_MOD_MASK&(r0_local[hptr_local] + r0_local[lptr]);
  r1_local[hptr_local] = INT_MOD_MASK&(r1_local[hptr_local] + r1_local[lptr]);
  temp2 = (r1_local[hptr_local]&(~1)) ^ (r0_local[hptr_local]>>1);
  *hp = (--hptr_local < 0) ? lv-1 : hptr_local;

  new_val = ((unsigned int) temp2*(double)FLT_MULT + (unsigned int) temp1)*FLT_MULT;

  return (new_val);
}

/*************************************************************************/
/*************************************************************************/
/*            INITIALIZE: starts the whole thing going                   */
/*************************************************************************/
/*************************************************************************/

static LFG ** initialize(int rng_type_local, int ngen_local, int param_local, unsigned seed_local, 
			 unsigned *nstart_local, unsigned initseed_local)
{
  int i,j,k,l,*order, length;
  LFG **q;
  unsigned *nindex;

  length = valid[param_local].L;

  /*      allocate memory for node number and fill of each generator       */
  //  order = (int *) mymalloc(ngen_local*sizeof(int));
  //  q = (LFG **) mymalloc(ngen_local*sizeof(LFG *));
  order = new int[ngen_local];
  q = new LFG *[ngen_local];

  if (q == NULL || order == NULL) 
    return NULL;

  for (i=0;i<ngen_local;i++) 
  {
    //  q[i] = (LFG *) mymalloc(sizeof(LFG));
    q[i] = new LFG;

    if (q[i] == NULL) 
      return NULL;

    q[i]->rng_type = rng_type_local;
    q[i]->hptr = length - 1;
    /*
    q[i]->si = (unsigned *) mymalloc((length-1)*sizeof(unsigned));
    q[i]->r0 = (unsigned *) mymalloc(length*sizeof(unsigned));
    q[i]->r1 = (unsigned *) mymalloc(length*sizeof(unsigned));
    */
    q[i]->si = new unsigned[length-1];
    q[i]->r0 = new unsigned[length];
    q[i]->r1 = new unsigned[length];
    q[i]->lval = length;
    q[i]->kval = valid[param_local].K;
    q[i]->param = param_local;
    q[i]->seed = seed_local;
    q[i]->init_seed = initseed_local;
    q[i]->gentype = (char *)GENTYPE;

    if (q[i]->r1 == NULL || q[i]->r0 == NULL || q[i]->si == NULL) 
      return NULL;
  }
/*      specify register fills and node number arrays                    */
/*      do fills in tree fashion so that all fills branch from index     */
/*           contained in nstart array                                   */
  q[0]->stream_number = nstart_local[0];
  si_double(q[0]->si,nstart_local,length);
  get_fill(q[0]->si,q[0]->r0,param_local,seed_local);
  q[0]->si[0]++;
  get_fill(q[0]->si,q[0]->r1,param_local,seed_local);

  i = 1;
  order[0] = 0;

  if (ngen_local>1) 
    while (1) 
    {
      l = i;
      for (k=0;k<l;k++) 
      {
	nindex = q[order[k]]->si;
	q[i]->stream_number = nindex[0];
	si_double(nindex,nindex, length);

	for (j=0;j<length-1;j++) 
	  q[i]->si[j] = nindex[j];

	get_fill(q[i]->si,q[i]->r0,param_local,seed_local);
	q[i]->si[0]++;
	get_fill(q[i]->si,q[i]->r1,param_local,seed_local);

	if (ngen_local == ++i) 
	  break;
      }
      
      if (ngen_local == i) 
	break;
                
      for (k=l-1;k>0;k--) 
      {
	order[2*k+1] = l+k;
	order[2*k] = order[k];
      }
      order[1] = l;
    }

  delete [] order;

  for (i=ngen_local-1;i>=0;i--) 
  {
    k = 0;
    
    for (j=1;j<lv-1;j++)
      if (q[i]->si[j]) 
	k = 1;
    if (!k) 
      break;
    for (j=0;j<length*RUNUP;j++)
      q[i]->get_rn_int();
  }

  while (i>=0)
  {
    for (j=0;j<4*length;j++) {
      q[i]->get_rn_int(); 
    }

    i--;
  }   

  return q;
}

/*************************************************************************/
/*************************************************************************/
/*            INIT_RNG's: user interface to start things off             */
/*************************************************************************/
/*************************************************************************/

LFG::LFG()
{
  rng_type = 0;
  gentype = NULL;
  si = NULL;
  r0 = NULL;
  r1 = NULL;
  stream_number = 0;
  hptr = 0;
  seed = 0;
  init_seed = 0;
  lval = 0;
  kval = 0;
  param = 0;
}

int LFG::init_rng(int g, int tg, int s, int pa)
{
  int doexit=0, i, k, length;
  LFG **p = NULL;
  unsigned *nstart=NULL, *si_local;

  
/*      gives back one generator (node gennum) with updated spawning     */
/*      info; should be called total_gen times, with different value     */
/*      of gennum in [0,total_gen) each call                             */

/*      check values of gennum and total_gen                             */

  if (tg <= 0) /* check if total_gen is valid */
  {
    tg = 1;
    errprint("WARNING","init_rng","Total_gen <= 0. Default value of 1 used for total_gen");
  }

  if (g >= MAX_STREAMS) /* check if gen_num is valid    */
    fprintf(stderr,"WARNING - init_rng: gennum: %d > maximum number of independent streams: %d\n\tIndependence of streams cannot be guranteed.\n",
	    g, MAX_STREAMS); 

  if (g < 0 || g >= tg) /* check if gen_num is valid */
  {
    errprint("ERROR","init_rng","gennum out of range. "); 
    return 0;
  }

  s &= 0x7fffffff;		/* Only 31 LSB of seed considered */
  
  if (pa < 0 || pa >= NPARAMS) 
  {
    errprint("WARNING","init_rng","Parameter not valid. Using Default param");
    pa = 0;
  }

/*      check whether generators have previously been defined            */
/*      guard against access while defining generator parameters for     */
/*            the 1st time                                               */
  length = valid[pa].L; /* determine parameters   */
  k = valid[pa].K;

  if (!lv) 
  {
    lv = length; /* determine parameters   */
    kv = k;
    gseed = s^GS0;
  }
  else 
  {
    if (lv != length) 
      doexit++;
    if(s != (gseed^GS0) ) 
      doexit += 2;

    if (doexit) 
    {
      if (doexit&1) 
	errprint("WARNING","init_rng","changing global L value! Independence of streams is not guaranteed");
      if (doexit&2) 
	errprint("WARNING","init_rng","changing global seed value! Independence of streams is not guaranteed");
    }
  }
  
  /*      define the starting vector for the initial node                  */
  //  nstart = (unsigned *) mymalloc((length-1)*sizeof(unsigned));
  nstart = new unsigned[length-1];

  if (nstart == NULL)
    return 0;

  nstart[0] = g;

  for (i=1;i<length-1;i++) 
    nstart[i] = 0;

  p = initialize(0,1,pa,s^GS0,nstart,s);  /* create a generator  */

  if (p == NULL) 
    return 0;
  
  p[0]->stream_number = g;

  /*      update si array to allow for future spawning of generators       */

  si_local = p[0]->si;

  while (si_local[0] < tg && !si_local[1]) 
    si_double(si_local,si_local,length);

  NGENS++;
      
  delete [] nstart;

  rng_type = 0;
  gentype = p[0]->gentype;
  si = p[0]->si;
  r0 = p[0]->r0;
  r1 = p[0]->r1;
  stream_number = p[0]->stream_number;
  hptr = p[0]->hptr;
  seed = p[0]->seed;
  init_seed = p[0]->init_seed;
  lval = p[0]->lval;
  kval = p[0]->kval;
  param = p[0]->param;

  delete [] p;

  return 1;
}

LFG::~LFG()
{
  free_rng();
}

LFG::LFG(const LFG & c)
{
  rng_type = c.rng_type;
  gentype = c.gentype;
  si = c.si;
  r0 = c.r0;
  r1 = c.r1;
  stream_number = c.stream_number;
  hptr = c.hptr;
  seed = c.seed;
  init_seed = c.init_seed;
  lval = c.lval;
  kval = c.kval;
  param = c.param;
}

LFG& LFG::operator= (const LFG & c)
{
  if (this != &c) {
    this->free_rng();

    rng_type = c.rng_type;
    gentype = c.gentype;
    si = c.si;
    r0 = c.r0;
    r1 = c.r1;
    stream_number = c.stream_number;
    hptr = c.hptr;
    seed = c.seed;
    init_seed = c.init_seed;
    lval = c.lval;
    kval = c.kval;
    param = c.param;
  }

  return * this;
}


/*************************************************************************/
/*************************************************************************/
/*                  SPAWN_RNG: spawns new generators                     */
/*************************************************************************/
/*************************************************************************/

int LFG::spawn_rng(int nspawned, Sprng ***newgens)
{
  LFG **q = NULL;
  int i;
  unsigned *p;
  
  if (nspawned <= 0) /* check if nspawned is valid */
  {
    nspawned = 1;
    errprint("WARNING","spawn_rng","Nspawned <= 0. Default value of 1 used for nspawned");
  }
  
  p = si;
  q = initialize(rng_type,nspawned,param,seed,p,init_seed);
  
  if (q == NULL) 
    {
      *newgens = NULL;
      return 0;
    }
  
  si_double(p,p,lval);

  NGENS += nspawned;
      
  *newgens = (Sprng **) q;

  return nspawned;
}

/*************************************************************************/
/*************************************************************************/
/*                  UTILITY ROUTINES                                     */
/*************************************************************************/
/*************************************************************************/

static int get_llag_rng(void)
{
        return(lv);
}

static int get_klag_rng(void)
{
        return(kv);
}

int LFG::get_seed_rng()
{
        return(GS0^gseed);
}

int LFG::get_hptr_rng()
{
  return hptr;
}

int * LFG::get_fill_rng()
{
  int i;
  int * p;
  unsigned *pp;
  
  //  p = (int *) mymalloc(2*lval*sizeof(int));
  p = new int[2*lval];

  if(p == NULL)
    return NULL;
  
  pp = r0;

  for (i=0;i<lv;i++)
    p[i] = pp[i];

  pp = r1;

  for (i=0;i<lval;i++)
    p[lval+i] = pp[i];

  return p;
}

int * LFG::get_next_index_rng()
{
  int i, lv;
  int * p;
  unsigned *pp;
      
  lv = lval;
  pp = si;
  //  p = (int *) mymalloc((lv-1)*sizeof(int));
  p = new int[lv-1];

  if(p == NULL)
    return NULL;
  
  for (i=0;i<lv-1;i++) 
    p[i] = pp[i];

  return p;
}

static void si_halve(int *a, int length)
{
  int i;
  
  for (i=0;i<length-2;i++) 
  {
    a[i] >>= 1;
    if (a[i+1]&1)
      a[i] ^= (1<<MAX_BIT_INT);
  }

  a[length-2] >>= 1;
}

int * LFG::get_node_index_rng()
{
  int *p, length;

  length = lval;
  p = get_next_index_rng();

  if(p == NULL)
    return NULL;
  
  while (!(p[0]&1)) 
    si_halve(p,length);
  si_halve(p, length);

  return(p);
}

 
/*************************************************************************/
/*************************************************************************/
/*                  MESSAGE PASSING ROUTINES                             */
/*************************************************************************/
/*************************************************************************/


int LFG::pack_rng(char **buffer)
{
  int i, size;
  unsigned char *p, *initp;
  
  size = 4 + (3*(lval)+5)*4 + strlen(gentype)+1;
  /* The new load/store routines make using sizeof unnecessary. Infact, */
  /* using sizeof could be erroneous. */
  initp = p = (unsigned char *) mymalloc(size);

  if(p == NULL)
  {
    *buffer = NULL;
    return 0;
  }
  
  p += store_int(rng_type,4,p);
  strcpy((char *)p,gentype);
  p += strlen(gentype)+1;
  p += store_int(lval,4,p);
  p += store_int(kval,4,p);
  p += store_int(seed,4,p);
  p += store_int(init_seed,4,p);
  p += store_int(stream_number,4,p);
  p += store_intarray(si,lval-1,4,p);
  p += store_intarray(r0,lval,4,p);
  p += store_intarray(r1,lval,4,p);
  p += store_int(hptr,4,p);

  *buffer = (char *) initp;
  assert(p-initp == size);
  
  return p-initp;
}

int LFG::unpack_rng(char * p)
{
  int doexit=0,i, found, length, k, param_local;
  unsigned seed_local, lag1, lag2;
  unsigned char *packed;
  int rng_type;
  
  packed = (unsigned char *) p;
  packed += load_int(packed,4,(unsigned int *)&rng_type);

  if(strcmp((char *)packed,GENTYPE) != 0)
  {
    fprintf(stderr,"ERROR: Unpacked ' %.24s ' instead of ' %s '\n", packed, GENTYPE); 
    return 0;
  }
  packed += strlen(GENTYPE)+1;
    
  packed += load_int(packed,4,&lag1);
  packed += load_int(packed,4,&lag2);
  packed += load_int(packed,4,&seed_local);
  
/*      check values of parameters for consistency                       */
  for(i=found=0; i<NPARAMS; i++)
    if(lag1==valid[i].L && lag2==valid[i].K)
    {
      found = 1;
      break;
    }
  
  if(found == 0)
  {
    fprintf(stderr,"ERROR: Unpacked parameters are not acceptable.\n");
    return 0;
  }

  param_local = i;
  length = valid[param_local].L;
  k = valid[param_local].K;

  if (!lv) 
  {
    lv = length;
    kv = k;
    gseed = seed_local;
  }
  else 
  {
    if (seed_local!=gseed)
    {
      errprint("WARNING","unpack_rng","different global seed value!");
      fprintf(stderr,"\t Independence of streams is not guaranteed\n");
    }
  }

  if(this == NULL) 
    return 0;
  
  rng_type = rng_type;
  gentype = (char *)GENTYPE;
  /*
  si = (unsigned *) mymalloc((length-1)*sizeof(unsigned));
  r0 = (unsigned *) mymalloc(length*sizeof(unsigned));
  r1 = (unsigned *) mymalloc(length*sizeof(unsigned));
  */
  si = new unsigned[length-1];
  r0 = new unsigned[length];
  r1 = new unsigned[length];

  if (r1 == NULL || si == NULL || r0 == NULL) 
    return 0;

  lval = length;
  kval = k;
  seed = seed_local;
  param = param_local;

  packed += load_int(packed,4,(unsigned int *)&init_seed);
  packed += load_int(packed,4,(unsigned int *)&stream_number);
  packed += load_intarray(packed,length-1,4,si);
  packed += load_intarray(packed,length,4,r0);
  packed += load_intarray(packed,length,4,r1);
  packed += load_int(packed,4,(unsigned int *)&hptr);

  NGENS++;

  return 1;
}

/*************************************************************************/
/*************************************************************************/
/*      FREE_RNG: remove memory for a generator                          */
/*************************************************************************/
/*************************************************************************/

int LFG::free_rng()
{
  delete [] this->si;
  delete [] this->r0;
  delete [] this->r1;
  //free(this);

  NGENS--;
      
  return NGENS;
}

int LFG::print_rng()
{
  printf("\n%s\n", GENTYPE+2);  
  printf("\n \tseed = %d, stream_number = %d\tparameter = %d\n\n", init_seed, stream_number, param);

  return 1;
}

