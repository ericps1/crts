<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="Transform.xsl"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1/docbookx.dtd">
<article>
  <title><inlinemediaobject>
      <imageobject>
        <imagedata fileref="raprLogo.gif"/>
      </imageobject>
    </inlinemediaobject><inlinemediaobject>
      <imageobject>
        <imagedata fileref="mgenLogo.gif"/>
      </imageobject>
    </inlinemediaobject>RAPR User's and Reference Guide</title>

  <titleabbrev>RAPR User's and Reference Guide</titleabbrev>

  <articleinfo>
    <abstract>
      <para>The <ulink
      url="http://www.nrl.navy.mil/itd/ncs/products/rapr">Real-time
      Application Representative (RAPR)</ulink> is open source software
      developed by the <ulink url="http://www.nrl.navy.mil/">Naval Research
      Laboratory (NRL)</ulink> PROtocol Engineernig Advanced Networking
      (PROTEAN) group and was designed to emulate generic application
      performance on IP networks using both UDP and TCP transport mechanisms.
      RAPR can generate and respond to real-time network traffic in a manner
      closely tied to application behavior so that the network can be loaded
      in a variety of ways in a controlled and repeatable manner. It uses the
      Mgen toolkit (MGEN) to generate network traffic and supports most of the
      traffic shaping functionality available in Mgen Version 5.0. The network
      traffic can be logged for subsequent analysis and can be used to
      calculate performance statistics on throughput, packet loss rates,
      communication delay, and more.</para>
    </abstract>
  </articleinfo>

  <sect1>
    <title>Introduction</title>

    <para>The Real-time Application Representative (RAPR) is open source
    software developed by the <ulink url="http://www.nrl.navy.mil/">Naval
    Research Laboratory</ulink> (NRL) PROTocol Engineering Advanced Networking
    (PROTEAN) group and was designed to emulate generic application
    performance on IP networks using both UDP and TCP transport
    mechanisms.</para>

    <para>RAPR can generate and respond to real-time network traffic in a
    manner closely tied to application behavior so that the network can be
    loaded in a variety of ways in a controlled and repeatable manner. It uses
    the Mgen toolkit (<ulink
    url="http://www.nrl.navy.mil/itd/ncs/products/mgen">MGEN</ulink>) to
    generate network traffic and supports most of the traffic shaping
    functionality available in Mgen Version 5.0. The network traffic can be
    logged for subsequent analysis and can be used to calculate performance
    statistics on throughput, packet loss rates, communication delay, and
    more.</para>

    <para>RAPR behavior is defined by a <link linkend="_input_script">RAPR
    input script</link>, a <link linkend="_behavior_table">behavior
    table</link>, and <link linkend="_RAPR_run-time_interface">RAPR run-time
    interface</link> to handle RAPR commands over a run-time interface. The
    <link linkend="_input_script">RAPR input script</link> is used to schedule
    emulated application behavior over a time line. The <link
    linkend="_RAPR_run-time_interface">RAPR run-time interface</link> can be
    used to inject and schedule additional RAPR behaviors. The <link
    linkend="_behavior_table">behavior table</link> defines behavior in
    response to network or application generated events. Additionally a <link
    linkend="_dictionary">dictionary</link> can be used to translate
    name-value pairs used by the application and scripts.</para>

    <para>RAPR behavior events fall into three categories: <link
    linkend="_Reception_Events">Reception Events</link> which direct RAPR to
    listen for specific network traffic, <link linkend="_Rapr_Events">RAPR
    Events</link> which direct the application itself (to load a <link
    linkend="_dictionary">dictionary</link> for example), and <link
    linkend="_Behavior_Events">Behavior Events</link> which direct RAPR to
    emulate generic application behavior.</para>

    <para><link linkend="_Behavior_Events">Behavior Events</link> are rather
    elementary and mainly are responsible for initiating network traffic. The
    set of behavior events include:</para>

    <itemizedlist>
      <listitem>
         

        <link linkend="_declarative">Declarative</link>

         Events which send TCP or UDP (unicast or multicast) traffic to a destination address and complete. 
      </listitem>

      <listitem>
         

        <link linkend="_interrogative">Interrogative</link>

         Events which send TCP or UDP (unicast or multicast) traffic to a destination address and then wait for a response. If a response is not received within a specified time period, the Interrogative Event will resend the message. 
      </listitem>

      <listitem>
         

        <link linkend="_stream">Stream</link>

         Events which send UDP multicast traffic and wait for and react to responses from other nodes listening to the multicast address. Stream events are currently designed to facilitate Voice over IP traffic patterns and emulate "conversations". 
      </listitem>

      <listitem>
         

        <link linkend="_periodic">Periodic</link>

         Events can be used to spawn other behavior event types (Declarative and Interrogative only) at regular intervals. These generated behavior events behave as independent events and have no relationship to one another. 
      </listitem>
    </itemizedlist>

    <para>It is the interaction between the generated network traffic
    initiated by these <link linkend="_Behavior_Events">Behavior Events</link>
    types and a target node(s) response as defined in its <link
    linkend="_behavior_table">behavior table</link>that together emulate
    network enabled application behavior. Generated traffic can be associated
    with a payload logic id that is used to direct the target node(s)
    response. The incoming payload logic id is then used to lookup any action
    to be taken in the receiving node's <link
    linkend="_behavior_table">behavior table</link> (e.g. respond with a
    declarative message, start a stream event object, etc.).</para>

    <para>The principle tool is the RAPR program which can generate, receive,
    and log test traffic. This document provides information on RAPR usage,
    message payload, script, table, and log file formats. Additional tools are
    available to facilitate automated script file creation and log file
    analyses.</para>
  </sect1>

  <sect1 id="Quick_Link">
    <title>Quick Links</title>

    <para><ulink url="http://pf.itd.nrl.navy.mil/rapr/rapr-tutorial.html">RAPR
    Tutorial</ulink></para>

    <para><link linkend="_sample_application">Sample Application</link></para>

    <para><link linkend="_RAPR_Usage:">RAPR Usage</link></para>

    <para><link linkend="_input_script">RAPR Input Script</link></para>

    <para><link linkend="_Behavior_Events">Behavior Events</link></para>

    <para><link linkend="_Reception_Events">Reception Events</link></para>

    <para><link linkend="_Rapr_Events">RAPR Events</link></para>

    <para><link linkend="_GLOBAL">Global Commands</link></para>

    <para><link linkend="_behavior_table">RAPR Behavior Table</link></para>

    <para><link linkend="_RAPR_run-time_interface">RAPR Run-time
    Interface</link></para>

    <para><link linkend="_dictionary">RAPR Dictionary</link></para>

    <para><link linkend="_RAPR_Log_File">RAPR Log File Format</link></para>

    <para><link linkend="_MGEN_Log_File">MGEN Log File Format</link></para>

    <para><link linkend="_RAPR_Message_Payload_1">RAPR Message
    Payload</link></para>

    <para><ulink
    url="http://www.nrl.navy.mil/itd/ncs/products/protean_tools">gpsLogger GPS
    Utility</ulink></para>
  </sect1>

  <sect1 id="_sample_application">
    <title>Sample Application</title>

    <para>The following example shows how to set up a
    <emphasis>simple</emphasis> web server application with one node acting as
    the <link linkend="_web_server">web server</link> and another node acting
    as a <link linkend="_web_client">web client</link>.</para>

    <para>The web server is modeled to be a simple stateless server that
    simply responds to various client requests. The web client drives the
    behavior by sending logic ids to the server that trigger its response, for
    example to return an "HTML web page". The traffic patterns are randomized
    such that the emulated behavior reflects the randomness of real traffic
    patterns but is repeatable.</para>

    <para>The sample application models two behavior "patterns":</para>

    <itemizedlist>
      <listitem>
         The client requests an HTML web page. After the server returns a "web page", the client requests between one and three gif files. 
      </listitem>

      <listitem>
         The client requests an HTML web page with a link to a file. The server responds with a file between 512 and 38192 bytes. 
      </listitem>
    </itemizedlist>

    <para>The steps in the sample application that model the client requesting
    an HTML web page are detailed below:</para>

    <note>
      <para>The examples below will work if run co-located with the rapr
      binary. They are also included in the rapr distribution with a few minor
      changes as discussed in the distribution.</para>
    </note>

    <para>STEP 1 The client's input script initiates the "application"
    behavior by directing the client to send a single mgen message between 76
    and 2048 bytes with a logic ID "1" to the server to emulate "requesting an
    html page". A PERIODIC object is used to repeat the behavior every 15 to
    30 seconds for six minutes:</para>

    <programlisting># Send a request every 15 to 30 seconds 
DURATION 360 PERIODIC INTERVAL %SYSTEM:RANDOMI(15,30)% DECLARATIVE TCP 
DST %SERVER:IP%/%HTTP_SERVER_PORT% PERIODIC [1 %SYSTEM:RANDOMI(76,2048)%] LOGICID 1 COUNT 1</programlisting>

    <para>STEP 2 The Server's behavior table directs it to return a TCP
    message between 76 and 2048 bytes to the sender of the triggering packet
    (%PACKET:SRCIP%) with a logic id of "2" in order to emulate "returning an
    html page":</para>

    <programlisting>   &lt;logicid&gt;
      &lt;!-- Logic id 1 initiates the interaction between the client
           and the server.  It is sent from the client to the server 
           and directs the server to send a single TCP packet
           or "web page" of random size with logic id 2 
           back to the client --&gt;
      &lt;id&gt;1&lt;/id&gt;
      &lt;entry&gt;DECLARATIVE TCP DST %PACKET:SRCIP%/%HTTP_CLIENT_PORT% 
             PERIODIC [1 %SYSTEM:RANDOMI(76,2048)%] COUNT 1 LOGICID 2&lt;/entry&gt;
    &lt;/logicid&gt;</programlisting>

    <para>STEP 3 Logic ID 2 in the client's behavior table causes it to send
    one to three more requests to the server (the originator of the packet
    referenced by %PACKET:SRCIP%), immediately upon receipt of the triggering
    packet with logic id 3. Note that the client has a 50 percent probability
    of making this second request:</para>

    <programlisting>     &lt;logicid&gt;
      &lt;!-- Logic id 2 is sent from the server to the client.
           It directs the client to send between 1 and 3
           TCP messages (or "requests for gif files") back to 
           the server.  These mesages(s) are associated with logic
           id 3. Note that the client has a 50% probability
           of making these requests. --&gt;
      &lt;id&gt;2&lt;/id&gt;
      &lt;percent&gt;0.5&lt;/percent&gt;
      &lt;entry&gt;DECLARATIVE TCP DST %PACKET:SRCIP%/%HTTP_SERVER_PORT% 
             POISSON [1 %SYSTEM:RANDOMI(76,2048)%] LOGICID 3 COUNT 
             %SYSTEM:RANDOMI(1,3)%&lt;/entry&gt;
    &lt;/logicid&gt;</programlisting>

    <para>STEP 4 The server then, immediately upon receipt of each message
    containing logic id 3, returns a tcp message between 512 and 38192 bytes
    to the client to emulate "sending a file":</para>

    <programlisting>    &lt;logicid&gt;
      &lt;id&gt;3&lt;/id&gt;
      &lt;!-- Logic if 3 is sent from the client to the server.
           It directs the server to send a single TCP message (or "file")
           between 512 and 38192 bytes back to the client.  It is
           not associated with a logic id and "ends" the 
           interaction initiated by logic id 1. The server will
           respond between 1 and 3 times depending on how many 
           "http requests" (or packets associated with logic id 3
           it received from the client.--&gt;
      &lt;entry&gt;DECLARATIVE TCP DST %PACKET:SRCIP%/%HTTP_CLIENT_PORT% 
             POISSON [1 %SYSTEM:RANDOMI(512,38192)%] COUNT 1&lt;/entry&gt;
    &lt;/logicid&gt;</programlisting>

    <para>The server did not include a logic id in the payload directing the
    client to perform any further behavior so the traffic pattern ends.</para>

    <para>Note that the server is "shutdown" 120 seconds into the test and
    will not reply to client requests until it is "restarted". The server
    input script uses the CHANGE_STATE command to affect this as illustrated
    in the web server input script.</para>

    <sect2 id="_web_server">
      <title>Web Server</title>

      <para>The <anchor id="_web_server"/>Web Server is configured to be a
      simple stateless server that simply responds to various client
      "requests". An <link linkend="_input_script">input script</link> must be
      defined to tell the RAPR application emulating the web server to
      "listen" for TCP traffic as well as to set default application
      parameters.</para>

      <sect3 id="Example_Web_Server_Input_Script">
        <title>Example Web Server Input Script</title>

        <para>This simple input script directs the server to start listening
        for TCP traffic. All server behavior is response driven as defined in
        the logic table.</para>

        <programlisting format="linespecific">
# Load the dictionary and logictable for the
# http application.  
LOAD_DICTIONARY dictionary-http.xml 
LOGICTABLE_FILE logictable-http.xml 


# Set unique hostId per rapr participant - this will default to the
# last octet of the node's ip address if not set
HOSTID 2

OVERWRITE_MGENLOG mgen-server-http.log
OVERWRITE_RAPRLOG rapr-server-http.log

# Listen for HTTP requests 
LISTEN TCP %HTTP_SERVER_PORT%

# Shutdown the server 120 seconds into the test
120.0 CHANGE_STATE %SERVER:STOPPED%

# Start the server back up a minute later, at 180 seconds into the test
180.0 CHANGE_STATE %SERVER:STARTED%

</programlisting>
      </sect3>

      <sect3 id="Example_Web_Server_Logictable">
        <title>Example Web Client Input Script</title>

        <para>This simple input script directs the client to start listening
        for TCP traffic. It initiates the emulated behavior via the PERIODIC
        behavior event. All server behavior is response driven as defined in
        the logic table.</para>

        <programlisting># Load the dictionary and logictable for the
# http application.  
LOAD_DICTIONARY dictionary-http.xml 
LOGICTABLE_FILE logictable-http.xml 


# Set unique hostId per rapr participant - this will default to the
# last octet of the node's ip address if not set
HOSTID 1


OVERWRITE_MGENLOG mgen-client-http.log
OVERWRITE_RAPRLOG rapr-client-http.log

# Listen for responses from the server
Listen TCP %HTTP_CLIENT_PORT%

# Send a request every 15 to 30 seconds 
DURATION 360 PERIODIC INTERVAL %SYSTEM:RANDOMI(15,30)% 
 DECLARATIVE SRC 5000 TCP DST %SERVER:IP%/%HTTP_SERVER_PORT% PERIODIC 
 [1 %SYSTEM:RANDOMI(76,2048)%] LOGICID 1 COUNT 1</programlisting>
      </sect3>

      <sect3 id="Example_Web_Server_Logictable">
        <title>Example Web Server Dictionary</title>

        <para>A common dictionary is used by both the http client and
        server.</para>

        <programlisting>&lt;RaprDictionary&gt;
   &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
       &lt;field&gt;HTTP_SERVER_PORT&lt;/field&gt;
       &lt;value&gt;8000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;HTTP_CLIENT_PORT&lt;/field&gt;
       &lt;value&gt;8001&lt;/value&gt;
   &lt;/item&gt;
   &lt;/namespace&gt;
   &lt;!-- Dictionary entries in the server name space should --&gt;
   &lt;!-- be referred to as %SERVER:&lt;FIELDNAME&gt;%, e.g.       --&gt;
   &lt;!-- %SERVER:IP%                                        --&gt;
   &lt;namespace&gt;
   &lt;label&gt;SERVER&lt;/label&gt;
       &lt;item&gt;
           &lt;field&gt;IP&lt;/field&gt;
           &lt;value&gt;10.0.0.2&lt;/value&gt;
       &lt;/item&gt;
       &lt;item&gt;
           &lt;field&gt;STARTED&lt;/field&gt;
           &lt;value&gt;0&lt;/value&gt;
       &lt;/item&gt;
       &lt;item&gt;
           &lt;field&gt;STOPPED&lt;/field&gt;
           &lt;value&gt;1&lt;/value&gt;
       &lt;/item&gt;
   &lt;/namespace&gt;
&lt;/RaprDictionary&gt;
</programlisting>
      </sect3>

      <sect3 id="Example_Web_Server_Log_File">
        <title>Example Web Server Logic Table</title>

        <para>A common logic table is used by both the http client and
        server.</para>

        <programlisting>
&lt;RaprLogicTable&gt;

  &lt;state&gt;
    &lt;!-- Default state, SERVER:STARTED --&gt;
    &lt;value&gt;0&lt;/value&gt;
    &lt;logicid&gt;
      &lt;!-- Logic id 1 initiates the interaction between the client
           and the server.  It is sent from the client to the server 
           and directs the server to send a single TCP packet
           or "web page" of random size with logic id 2 
           back to the client --&gt;
      &lt;id&gt;1&lt;/id&gt;
      &lt;entry&gt;DECLARATIVE TCP DST %PACKET:SRCIP%/%HTTP_CLIENT_PORT% PERIODIC 
             [1 %SYSTEM:RANDOMI(76,2048)%] COUNT 1 LOGICID 2&lt;/entry&gt;
    &lt;/logicid&gt;
    &lt;logicid&gt;
      &lt;!-- Logic id 2 is sent from the server to the client.
           It directs the client to send between 1 and 3
           TCP messages (or "requests for gif files") back to 
           the server.  These mesages(s) are associated with logic
           id 3. Note that the client has a 50% probability
           of making these requests. --&gt;
      &lt;id&gt;2&lt;/id&gt;
      &lt;percent&gt;0.5&lt;/percent&gt;
      &lt;entry&gt;DECLARATIVE TCP DST %PACKET:SRCIP%/%HTTP_SERVER_PORT% POISSON 
             [1 %SYSTEM:RANDOMI(76,2048)%] LOGICID 3 COUNT %SYSTEM:RANDOMI(1,3)%&lt;/entry&gt;
    &lt;/logicid&gt;
    &lt;logicid&gt;
      &lt;id&gt;3&lt;/id&gt;
      &lt;!-- Logic if 3 is sent from the client to the server.
           It directs the server to send a single TCP message (or "file")
           between 512 and 38192 bytes back to the client.  It is
           not associated with a logic id and "ends" the 
           interaction initiated by logic id 1. The server will
           respond between 1 and 3 times depending on how many 
           "http requests" (or packets associated with logic id 3
           it received from the client.--&gt;
      &lt;entry&gt;DECLARATIVE TCP DST %PACKET:SRCIP%/%HTTP_CLIENT_PORT% POISSON 
             [1 %SYSTEM:RANDOMI(512,38192)%] COUNT 1&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;

  &lt;state&gt;
      &lt;!-- The server script issues a CHANGE_STATE 
           command at 120 seconds into the test.  When
           the server is in this state (SERVER:STOPPED)
           it will not respond to any requests from the
           client. At 180 seconds into the test the
           server changes state back to SERVER:STARTED and the
           logic defind for SERVER:STARTED (state 0) 
           will be followed--&gt;
      &lt;value&gt;1&lt;/value&gt;
      &lt;logicid&gt;
      &lt;!-- Server shut down - no response --&gt;      
         &lt;id&gt;0&lt;/id&gt;
         &lt;entry&gt;&lt;/entry&gt;
      &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;

</programlisting>

        <para/>
      </sect3>

      <sect3 id="Example_Web_Server_Log_File">
        <title>Plot of Web Server Application Behavior</title>

        <para>NRL's TRPR application can be used to create a gnuplot with the
        following command: (By default trpr will log send data only. Add the
        "send" and "recv" data options to log both SEND and RECV data.)</para>

        <programlisting>
./trpr mgen input mgen-server-http.log auto X output mgen-server-http.plot Display the plot file via: gnuplot -persist mgen-server-http.plot </programlisting>

        <para>Display the plot file via: <programlisting>gnuplot -persist mgen-server-http.plot </programlisting>This
        is plot of the application behavior:</para>

        <para><inlinegraphic fileref="mgen-server-http-plot.png"/></para>
      </sect3>
    </sect2>

    <sect2>
      <title> Application Best Practices</title>

      <para>Application "best practices" are discussed below. Some of these
      are illustrated in the sample applications in the rapr
      distribution.</para>

      <sect3>
        <title>Set a HOSTID or INITIAL_SEED</title>

        <para>The initial seed used by all random behaviors in the system can
        be set via either the INTITIAL_SEED command or the HOSTID command. The
        first of these commands encountered will be used to initialize the
        seed used by the random number generator. If neither is set, the
        HOSTID will default to the last octet of the node's ip address and
        this value will be used as the initial seed. Doing so is not
        recommended however, as this assignment will not occur until AFTER any
        other scripted behaviors are processed and seeding may not work
        properly. It should be set prior to any other commands. Either as an
        event, e.g.:<programlisting>./rapr event "HOSTID 1" input &lt;inputScript&gt;</programlisting>or
        as the first entry in an input script<programlisting>HOSTID 1

....</programlisting><programlisting>INITIAL_SEED 10001

HOSTID 1</programlisting></para>
      </sect3>

      <sect3>
        <title>Use a default input script.</title>

        <para>Use a default input script to defined rapr attributes common to
        all applications.</para>

        <programlisting># This input script sets the defaults for
# all rapr apps in the examples directory

# Log only error conditions
DEBUG 0

# Enable verbose logging
VERBOSE

# Enable transmission logging
TXLOG

# Flush the log immediately
FLUSH

# Load default dictionary
LOAD_DICTIONARY /home/rapr/rapr-scripts/rapr-default-dictionary.xml
</programlisting>
      </sect3>

      <sect3>
        <title>Use a default dictionary</title>

        <para>Use a default dictionary to define common dictionary
        translations.</para>

        <programlisting>&lt;RaprDictionary&gt;
    &lt;namespace&gt; 
      &lt;label&gt;SystemDefaults&lt;/label&gt;
        &lt;!-- Application wide defaults --&gt;
      &lt;item&gt;
        &lt;field&gt;SCRIPT_PATH&lt;/field&gt;
        &lt;value&gt;/home/rapr/rapr-scripts&lt;/value&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;field&gt;HTTP_EXAMPLE_PATH&lt;/field&gt;
        &lt;value&gt;%SCRIPT_PATH%/simple-http-example&lt;/value&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;field&gt;HTTP_LOG_PATH&lt;/field&gt;
        &lt;value&gt;%HTTP_EXAMPLE_PATH%&lt;/value&gt;
      &lt;/item&gt;
    &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</programlisting>
      </sect3>

      <sect3>
        <title>Define a default directory structure</title>

        <para>As illustrated by the sample applications in the rapr source,
        the use of such conventions can simplify scripting. By default, RAPR
        will look in the current directory for input files. Given the default
        dictionary and input scripts discussed above, an application author
        need not redefine common defaults and directory paths in each script.
        For example given an application input script "http-server.input"
        located in the "application" directory (in these examples
        /home/rapr/rapr-scripts/simple-http-example):<programlisting>
# Load the default rapr dictionary that defines
# paths and other system defaults.  If this script
# is not co-located with the rapr binary specify 
# a path
INPUT rapr-defaults.input

# Load the dictionary and logictable for the
# http application.  
LOAD_DICTIONARY %HTTP_EXAMPLE_PATH%/dictionary-http.xml 
LOGICTABLE_FILE %HTTP_EXAMPLE_PATH%/logictable-http.xml 

# Accept rapr commands over "rapr-server" pipe
RAPRPIPE rapr-server

# Uncomment the following lines to log mgen and/or rapr
# logging to an output file.  The OVERWRITE_&lt;type&gt;LOG command 
# will overwrite any existing log files. The &lt;type&gt;LOG command
# will append to any existing log file.

OVERWRITE_MGENLOG %HTTP_LOG_PATH%/mgen-server-http.log
OVERWRITE_RAPRLOG %HTTP_LOG_PATH%/rapr-server-http.log

.... &lt;rest of script&gt;


</programlisting>the "application" could be run as: </para>

        <programlisting>cd /home/rapr/rapr-scripts

./rapr event "HOSTID &lt;n&gt;" input simple-http-example/http-server.input

</programlisting>
      </sect3>

      <sect3>
        <title>Default port ranges</title>

        <para>Although not necessary, it is recommended to use port ranges
        10,000 and above in the RAPR applications to deconflict with other
        services running on the system. It is a also good idea to define a
        port range specific to an application.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Host ID, Initial Seed, &amp; Repeatability</title>

    <para>RAPR uses a random number generator that can be seeded such that
    RAPR behavior and traffic patterns can be controlled and be repeatable
    across multiple scenario runs. Seeds are embedded within RAPR messages so
    that network initiated behavior is also repeatable. Likewise, the initial
    seed value can be changed so that multiple runs of the same scenario
    results in variable behavior and traffic patterns.</para>

    <para>RAPR will use the <link linkend="hostid">hostid</link> to seed the
    random number generator unless an <link
    linkend="initial_seed">INITIAL_SEED</link> value is provided. If no <link
    linkend="initial_seed">INITIAL_SEED</link> or <link
    linkend="hostid">hostid</link> is specified, the default HostID (the last
    octet of the IP address) will be used as the initial seed value.</para>

    <para>The INITIAL_SEED or the HOSTID should be sent to rapr via the event
    command before the input file is processed, or be included as the first
    line in the input script such that subsequent behaviors are seeded
    correctly. Whichever command received first is used as the seed. NOTE: if
    no initial_seed or hostid is set prior to input script processing no
    initial_seed is available for seeding entries in the script.</para>

    <para>Note that <link linkend="hostid">hostid</link> is also used by the
    RAPR application to identify it's own network traffic and as such must be
    unique within a set of interoperating rapr applications. Currently the
    maximum <link linkend="???">hostid</link> allowed is 255.</para>

    <para><emphasis>Important: <link
    linkend="initial_seed">INITIAL_SEED</link> and <link
    linkend="hostid">hostid</link> must be specified as the first entries in
    an input script as subsequent commands may require that random number
    draws be made. <link linkend="???">INITIAL_SEED</link> should always be
    specified first (if set), followed by <link linkend="hostid">hostid</link>
    (if set).</emphasis></para>
  </sect1>

  <sect1>
    <title>Unique Behavior Identifier (UBI)</title>

    <para>Each behavior event created by RAPR is associated with a Unique
    Behavior Identifier (UBI) that serves to uniquely identify behavior
    "events" in the system. Behavior events manage and control message
    transmission and reception and other "system behaviors" (e.g. load a
    dictionary file, join/leave a multicast group).</para>

    <para>It is also embedded in the payload of messages sent by interrogative
    events and is used by a RAPR instance to identify its own message traffic
    or responses to its own solicitations.</para>

    <para>For example, RAPR will embed a UBI in messages to which it expects a
    response. Interrogative objects that are soliciting a reply will do this
    for example. In the following log file message, the UBI is the first field
    in the RAPR data. (0104-01000073 is the hex equivalent of a ubi
    "1929379841").</para>

    <para><programlisting>11:45:40.277483 app&gt;RAPR type&gt;Interrogative action&gt;start ubi&gt;1929379841 \
eventSource&gt;script_event cnt&gt;0 mgenCmd&gt;"ON 1 UDP SRC 6000 DST \
192.168.1.103/5000 PERIODIC [1 1024 ] DATA [<emphasis role="bold">010401000073</emphasis>020403000000\
0304CBE4A304]"</programlisting>When the target RAPR responds to this message,
    it will embed the (now) "foreign ubi" in the payload of its
    responses.</para>

    <para><programlisting>15:45:40.284519 RECV proto&gt;UDP flow&gt;1 seq&gt;1 src&gt;192.168.1.103/33923 \
dst&gt;192.168.1.102/6000 sent&gt;15:45:40.282034 size&gt;1024 gps&gt;INVALID,\
999.000000,999.000000,-999 data&gt;12:0304B0F0810204<emphasis role="bold">0401000073</emphasis></programlisting>
    The RAPR receiving this response packet then looks for the interrogative
    object associated with this "foreign ubi" that is waiting for a reply. If
    it finds one, the "transaction" is considered successful and no further
    messages are sent.</para>
  </sect1>

  <sect1>
    <title>Script synchronization.</title>

    <para>To assist in starting application or "scenario" scripts across a
    network, RAPR provides a START command that designates an absolute start
    time. This &lt;hour:min:sec&gt; field corresponds to the relative script
    time of 0.0 seconds. All transmission and reception events will be
    scheduled relative to this absolute start time. The optional GMT suffix
    (no white space after the time) indicates that the clock time given is
    Greenwich Mean Time (GMT) rather than the operating systems local time
    zone. If no START command is given, RAPR schedules transmission and
    reception events relative to program startup. For example:</para>

    <para><programlisting>#Start RAPR exactly at 1:30PM local time
START 13:30:00

#Start RAPR at 30 seconds past 8:30 
START 8:30:30GMT</programlisting>When specifying an absolute start time, it is
    important that the system clocks of network nodes be synchronized via a
    time protocol such as NTP or GPS.</para>
  </sect1>

  <sect1>
    <title>RAPR System Defaults</title>

    <para>The RAPR application provides certain application wide default
    values. In addition, a "default" dictionary is provided in the RAPR
    distribution that can be used to override these application wide default
    values. If no default dictionary is loaded into a running RAPR application
    via a "LOAD_DICTIONARY" command RAPR will default to using the values as
    specified in the table below. The "dictionary Field" columns lists the
    dictionary field names that must be used in the DEFAULT system name space.
    The "system value" lists the internal application wide default that can be
    overridden in the default dictionary.</para>

    <para>The default dictionary is included in the RAPR distribution in the
    unix directory. It is called "raprDictionary.xml".</para>

    <para><table>
        <title>Default Dictionary</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Dictionary Field</entry>

              <entry align="center">System Value</entry>

              <entry align="center">Comments</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>RETRYINTERVAL</entry>

              <entry>10</entry>

              <entry>The default retry interval used by an interrogative
              object if no RETRYINTERVAL attribute is specified.</entry>
            </row>

            <row>
              <entry>NUMRETRIES</entry>

              <entry>3</entry>

              <entry>The default number of retries used by an interrogative
              object if no NUMRETRIES attribute is specified.</entry>
            </row>

            <row>
              <entry>PATTERN</entry>

              <entry>PERIODIC [1 1024]</entry>

              <entry>The default mgen flow pattern that is used for all
              behavior events when no PATTERN is specified.</entry>
            </row>

            <row>
              <entry>STREAMDURATION</entry>

              <entry>.99</entry>

              <entry>The default stream duration that is used by the
              interrogative object for each message query or as the default
              duration for declarative objects. See the object definitions for
              more details on how this interval is used/calculated.</entry>
            </row>

            <row>
              <entry>PROTOCOL</entry>

              <entry>UDP*</entry>

              <entry>The default protocol to be used by all behavior events.
              Note that this default can <emphasis>only</emphasis> be set in
              the default dictionary. No internal default PROTOCOL is set
              system wide. If no entry is set specified in the default
              dictionary, the PROTOCOL <emphasis>must</emphasis> be set on the
              command line for each behavior event.</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>
  </sect1>

  <sect1 id="_RAPR_Usage:">
    <title>RAPR Usage</title>

    <para>The RAPR version 1.x program must currently be launched from a
    command-line. To launch RAPR, use the following command-line
    syntax:</para>

    <para><programlisting>
RAPR [input &lt;scriptFile&gt;]
     [overwrite_raprlog &lt;logFile&gt;] 
     [raprlog &lt;logFile&gt;]
     [overwrite_mgenlog &lt;logFile&gt;]
     [mgenlog &lt;logFile&gt;]
     [binary]
     [event "&lt;RAPR event&gt;"]
     [instance &lt;name&gt;]
     [offset &lt;offsetTime&gt;]
     [start &lt;startTime&gt;]
     [verbose]
     [enable_load_emulator]
     [initial_seed &lt;initial_seed&gt;]
     [hostid &lt;hostid&gt;]
     [txlog]
     [nolog]
     [flush]
     [interface &lt;interfaceName&gt;]
     [ttl &lt;timeToLive&gt;]
     [tos &lt;typeOfService&gt;]
     [label &lt;value&gt;]
     [txbuffer &lt;txSocketBufferSize&gt;]
     [rxbuffer &lt;rxSocketBufferSize&gt;]
     [txcheck]
     [rxcheck]
     [check]
     [stop]
     [debug &lt;debugLevel&gt;]
</programlisting></para>

    <para>Most of these command-line options can also be included in the RAPR
    input script.</para>

    <sect2 id="Command-line_Options">
      <title>Command-line Options</title>

      <para>Some of these command-line options can also be included in RAPR
      script files as "<link linkend="_GLOBAL">global</link>" commands or
      defaults. Note the command-line (or commands sent via RAPR's remote
      control interface) will always override settings from script
      files.</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry><link linkend="_INPUT">input</link>
              &lt;scriptFile&gt;</entry>

              <entry>Causes RAPR, to parse the given &lt;scriptFile&gt; at
              startup and schedule any transmission or reception events given
              in the script.</entry>
            </row>

            <row>
              <entry><link
              linkend="_OVERWRITE_RAPRLOG">overwrite_raprlog</link>
              &lt;logFile&gt;</entry>

              <entry>Causes RAPR to output RAPR behavior event and application
              information to the indicated &lt;logFile&gt;. By default, RAPR
              will log to stdout. With the overwrite_raprlog command, an
              existing &lt;logFile&gt; of the same name will be overwritten.
              Use the raprlog command to append to an existing log file. Some
              application errors are only logged to stdout.</entry>
            </row>

            <row>
              <entry><link linkend="_RAPRLOG">raprlog</link>
              &lt;raprlog&gt;</entry>

              <entry>This is the same as the overwrite_raprlog command except
              that if &lt;logFile&gt; already exists, it will be appended
              instead of replaced.</entry>
            </row>

            <row>
              <entry><link
              linkend="_OVERWRITE_MGENLOG">overwrite_mgenlog</link>
              &lt;logFile&gt;</entry>

              <entry>Causes RAPR to output mgen traffic information to the
              indicated &lt;logFile&gt;. By default, RAPR will log to stdout.
              With the overwrite_mgenlog command, an existing &lt;logFile&gt;
              of the same name will be overwritten. Use the mgenlog command to
              append to an existing log file.</entry>
            </row>

            <row>
              <entry><link linkend="_MGENLOG">mgenlog</link>
              &lt;mgenlog&gt;</entry>

              <entry>This is the same as the overwrite_mgenlog command except
              that if &lt;logFile&gt; already exists, it will be appended
              instead of replaced.</entry>
            </row>

            <row>
              <entry><link linkend="_Binary">binary</link></entry>

              <entry>Causes RAPR to save mgen output logging information in a
              smaller-sized binary file format. This option should come before
              the mgenlog or overwrite_mgenlog or log commands.</entry>
            </row>

            <row>
              <entry>event "&lt;RAPR event&gt;"</entry>

              <entry>The event command allows the user to enter the equivalent
              of RAPR script lines into RAPR via the command-line. Multiple
              event commands can be used to pass the equivalent of a
              multi-line script to RAPR. Note that RAPR script events
              generally contain spaces and thus must be encapsulated in quotes
              on the command line. Note that the &lt;eventTime&gt; may be
              omitted and the action indicated by the event will be taken by
              RAPR immediately.</entry>
            </row>

            <row>
              <entry><link linkend="_RAPR_run-time_interface">instance</link>
              &lt;instanceName&gt;</entry>

              <entry>If a pre-existing RAPR application instance is _not_
              already running, this command registers the running RAPR program
              as an instance identified by the &lt;instanceName&gt;. On UNIX,
              this corresponds to a Unix-domain datagram socket named
              "/tmp/&lt;instanceName&gt;" being opened and monitored for RAPR
              commands These interprocess channels allow for run-time control
              of RAPR processes. If an application instance as identified by
              the &lt;instanceName&gt; parameter is already running, any
              subsequent command-line options are transmitted to the remote
              instance already running, and the new RAPR instance will then
              exit.This allows run-time control of possibly multiple
              background RAPR instances from the "shell" or via scripting. The
              event command may be used to dispatch RAPR script events to RAPR
              instances at run-time.</entry>
            </row>

            <row>
              <entry><link linkend="_OFFSET">offset</link> &lt;sec&gt;</entry>

              <entry>Causes RAPR to skip &lt;sec&gt; seconds of relative time
              into the execution of the script file used. Note that if an
              absolute start time is given using the start command, the offset
              into the script will correspond to that absolute time. The
              default offset for RAPR is 0.0 seconds.</entry>
            </row>

            <row>
              <entry><link linkend="_START">start</link>
              &lt;hr:min:sec&gt;[GMT]</entry>

              <entry>Causes RAPR to delay processing events in script file
              relative to the indicated absolute time. The optional "GMT"
              keyword indicates the time is Greenwich Mean Time instead of the
              default local time. This command establishes an absolute time
              for the relative script time of 0.0 seconds.</entry>
            </row>

            <row>
              <entry>verbose</entry>

              <entry>This causes raprlog output to be more verbose.</entry>
            </row>

            <row>
              <entry>enable_load_emulator</entry>

              <entry>This enables application load emulation functionality in
              the RAPR application. This feature is not fully
              implemented.</entry>
            </row>

            <row>
              <entry><link linkend="hostid">hostid</link></entry>

              <entry>This command specifies the HOSTID to be used by RAPR.
              Although available as a command-line option, it is not
              recommended to be used this way as it will be overwritten by any
              subsequent HOSTID definitions in the input script if specified.
              HOSTID is embedded in unique behavior identifiers (see <link
              linkend="_ubi_state">CHANGE_UBI_STATE</link> for more
              information on UBI) that are used by the RAPR application to
              identify it's own network traffic and as such must be unique
              within a set of interoperating RAPR applications. If no HOSTID
              command is specified, the application will use the DEFAULT
              hostId as indicated by the node's local ip address. For example,
              given an ip address of 192.168.1.103, "103" will be used as the
              hostid if not overridden by the HOSTID command.</entry>
            </row>

            <row>
              <entry>initial_seed</entry>

              <entry>This command specifies the default initial seed used by
              RAPR. If not specified, the DEFAULT host id as indicated by the
              node's local ip address will be used as the initial_seed
              value.</entry>
            </row>

            <row>
              <entry>txlog</entry>

              <entry>This enables transmission logging. This results in
              transmitted network events being added to the log file every
              time a packet is sent by RAPR (MGEN).</entry>
            </row>

            <row>
              <entry>nolog</entry>

              <entry>This disables mgen logging completely.</entry>
            </row>

            <row>
              <entry>flush</entry>

              <entry>This causes the output log file to be flushed with each
              line written. This is useful for real-time monitoring of RAPR
              logging</entry>
            </row>

            <row>
              <entry><link linkend="_INTERFACE">interface</link>
              &lt;interfaceName&gt;</entry>

              <entry>Causes RAPR to set the default network interface for IP
              multicast and/or root node flow transmission to
              &lt;interfaceName&gt;. &lt;interfaceName&gt; will override any
              default interface specified within an RAPR script file.
              &lt;interfaceName&gt; is a "per socket" attribute, and in its
              absence, RAPR will behave according to the operating system's
              default behavior.</entry>
            </row>

            <row>
              <entry><link linkend="_TTL">ttl</link>
              &lt;timeToLive&gt;</entry>

              <entry>Causes RAPR to set the hop count for IP multicast traffic
              generated by RAPR. &lt;timeToLive&gt; will override any default
              ttl indicated within an RAPR script file. &lt;timeToLive&gt; is
              a "per socket" attribute. If no ttl option is used, RAPR will
              behave according to the operating system's default
              behavior.</entry>
            </row>

            <row>
              <entry><link linkend="_TOS">tos</link>
              &lt;typeOfService&gt;</entry>

              <entry>Causes RAPR to set the IPv4 type-of-service field (within
              the packet header) to &lt;typeOfService&gt;.
              &lt;typeOfService&gt; will override any default tos indicated
              within an RAPR script file. As with ttl and interface, tos is a
              "per socket" attribute. If no tos option is used, RAPR will
              behave according to the operating system's default
              behavior.</entry>
            </row>

            <row>
              <entry><link linkend="_LABEL">label</link> &lt;value&gt;</entry>

              <entry>Causes RAPR to set &lt;value&gt; as the default flow
              label for IPv6 flows. The &lt;value&gt; corresponds to the
              28-bit IPv6 flow label field and may be specified in decimal or
              hex.</entry>
            </row>

            <row>
              <entry><link linkend="_TXBUFFER">txbuffer</link>
              &lt;bufferSize&gt;</entry>

              <entry>Causes RAPR to set the socket transmit buffer size to a
              value Òat leastÓ as large as &lt;bufferSize&gt;. If
              &lt;bufferSize&gt; is larger that the maximum allowed by the
              system, &lt;bufferSize&gt; will be set to the system
              maximum.</entry>
            </row>

            <row>
              <entry><link linkend="_RXBUFFER">rxbuffer</link>
              &lt;bufferSize&gt;</entry>

              <entry>Causes RAPR to set the socket receive buffer size to a
              value Òat leastÓ as large as &lt;bufferSize&gt;. If
              &lt;bufferSize&gt; is larger that the maximum allowed by the
              system, &lt;bufferSize&gt; will be set to the system
              maximum.</entry>
            </row>

            <row>
              <entry>txcheck</entry>

              <entry>Causes RAPR to include an optional 32-bit cyclic
              redundancy checksum (CRC) at the end of its messages. The
              CHECKSUM flag is set to indicate the presence of the checksum
              content.</entry>
            </row>

            <row>
              <entry>rxcheck</entry>

              <entry>Forces RAPR receivers to validate the checksum portion
              (last 4 bytes) of RAPR messages whether or not the CHECKSUM flag
              is set in the RAPR flags message field. Use this option when it
              is _known_ that the RAPR sender is supplying checksums to cover
              the case when the flags field itself is possibly
              corrupted.</entry>
            </row>

            <row>
              <entry>check</entry>

              <entry>Sets RAPR behavior as if both the txcheck _and_ rxcheck
              commands were applied. This is the recommended option when RAPR
              checksum operation is desired so that both senders and receivers
              are providing and validating checksums, respectively.</entry>
            </row>

            <row>
              <entry>stop</entry>

              <entry>This command causes RAPR to exit. This is useful for
              run-time control of RAPR instances.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Upper and Lower case support</title>

      <para>All RAPR commands and behavior events can be scripted in both
      lower case and upper case, e.g. both the following formats are
      acceptable:<programlisting>DECLARATIVE UDP SRC 5000 DST 192.168.1.100/6000
declarative udp src 5000 dst 192.168.1.100/6000</programlisting></para>
    </sect2>

    <sect2>
      <title>Shorthand</title>

      <para>Shorthand notation is available for certain attributes,
      e.g.</para>

      <programlisting>DECLAR DST 192.168.1.100/5000 
INTERR DST 192.168.1.100/5000</programlisting>
    </sect2>

    <sect2 id="Example_Usage">
      <title>Example Usage</title>

      <para>To run RAPR with script file "script.mgn" and log to stdout (by
      default):</para>

      <programlisting>RAPR input script.mgn</programlisting>

      <para>The "event" command can be used to invoke RAPR commands with the
      command-line syntax:</para>

      <programlisting>RAPR event "listen udp 5000,5004-5006" mgenlog log.mgn</programlisting>

      <para>The "event" command allows for use of RAPR without script files
      for "quick and dirty" runs. RAPR is capable of being dynamically
      scripted during run time with "event" commands passed to RAPR via
      inter-process communication (see RAPR Run-Time Remote Control.</para>
    </sect2>
  </sect1>

  <sect1 id="_RAPR_run-time_interface">
    <title>Run-Time Interface</title>

    <para>To use the RAPR "remote control interface":</para>

    <para>Start one (or more) instance(s) of RAPR to control, either by the
    command line: RAPR instance RAPR1 or by the <link
    linkend="_raprpipe">RAPRPIPE</link> command in a RAPR input script.</para>

    <para>Subsequent invocations of RAPR with the same instance name will pass
    provided commands to the first instance and then exit: (Note that the
    quotes around the event definition are required.)</para>

    <programlisting>
RAPR instance RAPR1 event "0.0 DECLARATIVE UDP DST 127.0.0.1/5000 PERIODIC [1 1024]"</programlisting>

    <para>The second instance (Step #2) will exit after it has passed its
    commands to the first running instance as identified by the
    &lt;instanceName&gt;. Note this can allow run-time control of multiple
    RAPR instances by user(s), shell scripts, or other processes. A programmer
    comfortable with use of Unix-domain sockets or using the NRL Protolib
    "ProtoPipe" C++ class can also write software for run-time control of RAPR
    processes.</para>

    <para>Specifying a 0.0 start time for the events will cause the behavior
    event to start immediately, e.g. as soon as the event is parsed. Otherwise
    the event will be scheduled relative to the running rapr's offset
    time.</para>
  </sect1>

  <sect1 id="_behavior_table">
    <title>Behavior Event Table</title>

    <para>The Behavior Event Table, sometimes referred to as "a logic table "
    is used to define a node's response to a logic id. The behavior associated
    with a logic id in the behavior event table is the same as that that can
    be defined in an <link linkend="_input_script">input script</link> or over
    the <link linkend="_RAPR_run-time_interface">run-time interface</link>,
    e.g. <link linkend="_Behavior_Events">behavior events</link>,<link
    linkend="_Reception_Events">reception events</link>, and <link
    linkend="_Rapr_Events">rapr events</link>. The logic id may come from the
    following <anchor id="_triggering_event"/>triggering events:</para>

    <itemizedlist>
      <listitem>
         a payload logic id of an incoming network packet 
      </listitem>

      <listitem>
         a 

        <link linkend="_LOGICID">LOGICID</link>

         RAPR event command 
      </listitem>

      <listitem>
         from a SUCCESS, TIMEOUT, or FAILURE logic ID associated with a local 

        <link linkend="_Behavior_Events">behavior event</link>

         . 
      </listitem>
    </itemizedlist>

    <para>The behavior event table is created when a behavior event XML file
    is parsed. The format of this XML file is (briefly):</para>

    <programlisting>
&lt;RaprLogicTable&gt;
   &lt;<link linkend="_state">state</link>&gt;
      &lt;value&gt;STATE&lt;/value&gt;
   &lt;<link linkend="_logicid">logicid</link>&gt;
      &lt;id&gt;ID&lt;/id&gt;
          &lt;<link linkend="_percent">percent</link>&gt;PERCENT&lt;/percent&gt;
           &lt;<link linkend="_entry">entry</link>&gt;ENTRY&lt;/entry&gt;
           &lt;<link linkend="_entry">entry</link>&gt;ENTRY&lt;/entry&gt;
   &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting>

    <sect2 id="_state">
      <title>&lt;state&gt;</title>

      <para>The &lt;state&gt; XML tag forms a block around logic id's that can
      be used when the RAPR application is in that system <link
      linkend="_state">state</link>. Multiple state blocks can be defined in
      the same file.</para>

      <para>State value has the format &lt;globalState,ubiState&gt;. See <link
      linkend="_ubi_state">ubi state</link> for more information on the use of
      the optional ubi state attribute. &lt;globalState&gt; has the format
      &lt;x.y.z&gt; where x,y, and z are integers. If no &lt;state&gt; tag is
      defined, only the default state &lt;0&gt; will exist. System state is
      changed by the <link linkend="_CHANGE_STATE">CHANGE_STATE</link> rapr
      event command.</para>

      <para>For legibility, the <link
      linkend="_dictionary">dictionary's</link> function can be used to
      translate the state value from a more readable english format to its
      integer counterpart. (E.g. global state might be defined as
      &lt;SHUTTING_DOWN&gt; in the behavior table rather than n.n.n).</para>

      <programlisting>
&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;value&gt;%SHUTTING_DOWN%&lt;/value&gt;
         &lt;logicid&gt;
            &lt;id&gt;2&lt;/id&gt;
                &lt;entry&gt;CHANGE_STATE %STOPPED%&lt;/entry&gt;
         &lt;/logicid&gt;
   &lt;/state&gt;
   &lt;state&gt;
      &lt;value&gt;2.2.0&lt;/value&gt;
         &lt;logicid&gt;
            &lt;id&gt;2&lt;/id&gt;
                &lt;entry&gt;CHANGE_STATE %STARTED%&lt;/entry&gt;
         &lt;/logicid&gt;
   &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting>

      <para>See additional notes on <link linkend="_ubi_state">UBI
      state</link> below.</para>
    </sect2>

    <sect2 id="_logicid">
      <title>&lt;logicid&gt;</title>

      <para>The &lt;logicid&gt; tag forms a block around the
      &lt;behavior(s)&gt; to be performed when the specified ID is recieved
      when the system is in the state corresponding to the surrounding
      &lt;state&gt; block. The ID is the integer id value assigned to the
      logicid tag and is a required field.</para>
    </sect2>

    <sect2 id="_percent">
      <title>&lt;percent&gt;</title>

      <para>PERCENT is an optional field that defines the probability of
      triggering the event. The percentage is a float between 0 and 1. If the
      value is not defined, a 1 is assigned as the default, (always do the
      behavior). The <link linkend="_SEED">seed</link> of the triggering event
      is used to calculate the probability of response.</para>
    </sect2>

    <sect2 id="_entry">
      <title>&lt;entry&gt;</title>

      <para>ENTRY is the tag that identifies the behavior to invoke in
      response to the logic ID. Multiple entries can be specified for a given
      logic id. A minimum of one entry is required, there is no maximum limit.
      The format of the specified behavior events is the same as that defined
      for the <link linkend="_input_script">input script</link> or over the
      <link linkend="_RAPR_run-time_interface">run-time interface</link>, e.g.
      <link linkend="_Behavior_Events">behavior events</link>,<link
      linkend="_Reception_Events">reception events</link>, and <link
      linkend="_Rapr_Events">RAPR events</link>.</para>

      <para><emphasis role="bold">Important:</emphasis> Specifying a 0.0 start
      time for the events will cause the behavior event to start immediately,
      e.g. as soon as the event is parsed. Otherwise the event will be
      scheduled relative to the current offset time.</para>

      <para>For example, if the test offset time is 10 seconds, a behavior
      event specified in the table to start at time 5.0 would start in 5
      seconds, at test time 15.0. Any event in which NO start time is
      specified would be scheduled to start at test time 10.0 seconds. Note
      that his may result in additional behaviors being scheduled prior to the
      given event. It is particularly important to fully specify a 0.0 start
      time when doing state changes in order to control the ordering in which
      multiple events are enqueued.</para>

      <programlisting>
&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;value&gt;0.0.0&lt;/value&gt;
         &lt;logicid&gt;
            &lt;id&gt;1&lt;/id&gt;
               &lt;entry&gt;STOP 5.0 DECLARATIVE UDP SRC 5001 
                          DST 192.168.1.102/5000 
                          PERIODIC [1 2048] LOGICID 9&lt;/entry&gt;
               &lt;/logicid&gt;
      &lt;logicid&gt;
         &lt;id&gt;5&lt;/id&gt;
            &lt;percent&gt;0.8&lt;/percent&gt;
               &lt;entry&gt;DECLARATIVE UDP SRC 6001 DST %PACKET:SRCIP%/5001 
                          LOGICID 11 SEED %PACKET:SEED%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
         &lt;id&gt;8&lt;/id&gt;
            &lt;entry&gt;DECLARATIVE UDP SRC 5001 DST 192.168.1.102/5000&lt;/entry&gt; 
            &lt;entry&gt;DURATION 10.0 INTERROGATIVE RETRYINTERVAL 1.0 
                       NUMRETRIES 5 UDP SRC 5001 DST 192.168.1.100/5000 
                       PERIODIC [1 2048] FAILURE 4&lt;/entry&gt;
      &lt;/logicid&gt;
   &lt;/state&gt;
&lt;RaprLogicTable&gt;
</programlisting>
    </sect2>

    <sect2 id="_word_replacement">
      <title>Word Replacement in the Behavior Table</title>

      <para>Word replacement is supported in the behavior table xml file so
      that scripting of the logic table is more legible and more easily
      standardized across multiple machines using a common <link
      linkend="_dictionary">dictionary</link>. For example, given a <link
      linkend="_dictionary">dictionary</link> translation defined as:</para>

      <programlisting>
   &lt;item&gt;
     &lt;field&gt;TN-61&lt;/field&gt;
     &lt;value&gt;192.168.2.61&lt;/value&gt;
   &lt;/item&gt;
</programlisting>

      <para>The behavior table &lt;entry&gt; of:</para>

      <programlisting>
&lt;entry&gt;DECLARATIVE UDP SRC 6001 DST %TN-61%/5001 LOGICID 11
</programlisting>

      <para>Would be translated to:</para>

      <programlisting>
DECLARATIVE UDP SRC 6001 DST 192.168.2.61/5001 PERIODIC [1 1024] LOGICID 11
</programlisting>

      <para>as the logic table is interpreted.</para>
    </sect2>

    <sect2 id="_namespace">
      <title>Name Spaces in the Behavior Table</title>

      <para>The <link linkend="_dictionary-namespace">dictionary's
      namespace</link> feature can also be used to differentiate common
      dictionary names. For example, the IP address of the incoming packet and
      the IP address of the machine might both be referred to as
      &lt;SRCIP&gt;. The PACKET namespace (that is reserved for information
      stored in the incoming packet) could be used to refer to the IP address
      of the incoming packet. For example:</para>

      <programlisting>
DECLARATIVE UDP SRC 6001 DST %PACKET:SRCIP%/5001 PERIODIC [1 2048] LOGICID 11
</programlisting>

      <para>See <link linkend="_dictionary">dictionary</link> for more
      information</para>
    </sect2>

    <sect2 id="_ubi_state">
      <title>UBI State in the Behavior Table</title>

      <para>UBI is an unique behavior identifier associated with each behavior
      triggered by the script or logic table. The idea behind UBI State is to
      be able to handle multiple packet requests and retries (from an <link
      linkend="_interrogative">INTERROGATIVE</link> event that did not
      successfully receive a response packet for example).</para>

      <para>An example might best illustrate an application of this
      functionality: Node A requests a response from Node B. Node B is
      configured to respond to the request with an "acknowledgement" (or
      single declarative response) and after a random interval, to send a
      "file" (a multi-packet declarative response) back to the Node A. When
      Node B receives the triggering request, it should respond with the
      acknowledgement and schedule the transmission of the file after the
      random interval.</para>

      <para>Without using UBI state change functionality, if Node A did not
      not receive the initial acknowledgement, and retransmitted a second
      request for the information, Node B would respond with a second
      acknowledgement and schedule the transmission of a second file after a
      random interval.</para>

      <para>UBI State change can be used to direct Node B to "remember" that
      is has already successfully received the initial response. When Node B
      receives the first response, it can change the state associated with the
      initial message, so that any subsequent responses only generate
      "acknowledgements" of the request, not additional file responses (if
      that is the desired behavior).</para>

      <para>Every action received will start at UBI State 0. A change in the
      UBI state of each action can be accomplished by a "<link
      linkend="_change_ubi_state">CHANGE_UBI_STATE</link> %packet:ubi% x"
      command where x is the new UBI State. This command is only available in
      the Logic Table as it only pertains to incoming data packet. The idea is
      to be able to determine whether a request from an interrogative event
      has already been acted upon or is it the first time encountering the
      packet.</para>

      <programlisting>
&lt;RaprLogicTable&gt;
   &lt;state&gt;
       &lt;value&gt;STATE,UBI_STATE&lt;/value&gt;
       &lt;logicid&gt;
	          ...
       &lt;logicid&gt;
   &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting>

      <note>
        <para>The ~first~ packet received associated with an interrogative
        object's ubi will trigger the interrogative object to "succeed" and
        any logic id associated with this ~first~ packet will be
        processed.</para>

        <para>Likewise, any logic id's associated with any subsequent packets
        will be processed, which may be sent by different data streams - e.g.
        two declaratives responding to the initial interrogative query that
        are associated with payload logic id's.</para>

        <para>Note that if the user is relying on any ubi state changes to
        effect behavior - he must take care that he provisions for both logic
        id's in both table states and consider the order in which they may
        arrive, and the state of the table in which they arrive. E.g. if one
        logic id causes a ubi state change - all subsequent logic id's
        received that are associated with that ubi will be looked up in the
        ubi state table.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="_dictionary">
    <title>Dictionary</title>

    <para>The Dictionary can be used to translate name-value pairs used in the
    event definitions in the <link linkend="_input_script">input script</link>
    and <link linkend="_behavior_table">behavior table</link>. The dictionary
    is created when the dictionary XML file is parsed. The format of this XML
    file is (briefly):</para>

    <programlisting>
&lt;RaprDictionary&gt;
   &lt;<link linkend="_dictionary-namespace">namespace</link>&gt;
      &lt;label&gt;NAMESPACENAME&lt;/label&gt;
   &lt;item&gt;
       &lt;<link linkend="_field">field</link>&gt;FIELDNAME&lt;/field&gt;
        &lt;<link linkend="_value">value</link>&gt;VALUE1&lt;/value&gt;
        &lt;<link linkend="_value">value</link>&gt;VALUE2&lt;/value&gt;
   &lt;/item&gt;
   &lt;/namespace&gt;
&lt;/RaprDictionary&gt;

</programlisting>

    <sect2 id="_dictionary-namespace">
      <title>Namespace in the Dictionary</title>

      <para>The NAMESPACE tag is used to differentiate common dictionary names
      that can be referenced by the format %NAMESPACE-LABEL:VALUE-NAME%. In
      the event that %VALUE-NAME is not specified in the given namespace, the
      replacement will be the first match of the field name over all the
      namespaces. (See <link linkend="_reserved_namespaces">reserved
      namespaces</link> for more namespace options.) For example, given a
      namespace definition of:</para>

      <programlisting>
&lt;namespace&gt;
   &lt;label&gt;HOST&lt;/label&gt;
       &lt;item&gt;
           &lt;field&gt;SRCIP&lt;/field&gt;
           &lt;value&gt;192.168.1.2&lt;/value&gt;
        &lt;/item&gt;
&lt;/namespace&gt;
</programlisting>

      <para>%HOST:SRCIP% will be translated to the value "192.168.1.2"</para>
    </sect2>

    <sect2 id="_field">
      <title>Field</title>

      <para>FIELDNAME is the name of the word to be replaced without the %
      surrounding the word. %DESTINATION% in the following example would be
      translated to "192.168.2.102". This is a required field.</para>

      <programlisting>
&lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
      &lt;field&gt;DESTINATION&lt;/field&gt;
      &lt;value&gt;192.168.2.102&lt;/value&gt;
   &lt;/item&gt;
&lt;/namespace&gt;
</programlisting>
    </sect2>

    <sect2 id="_value">
      <title>Value</title>

      <para>The VALUE entry should contain the values used to replace the
      field. Multiple values can be assigned to the same field. Each will be
      used to create an independent statement. Null is a valid entry for the
      value. One or more values are required. Given the example:</para>

      <programlisting>
&lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
      &lt;field&gt;LOCALHOST&lt;/field&gt;
      &lt;value&gt;127.0.0.1&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;DESTINATION&lt;/field&gt;
      &lt;value&gt;192.168.2.102&lt;/value&gt;
      &lt;value&gt;192.168.2.103&lt;/value&gt;
   &lt;/item&gt;
&lt;/namespace&gt;
</programlisting>

      <para>and given an event definition of:</para>

      <programlisting>
DECLARATIVE UDP SRC 5000 DST %DESTINATION%/5001
</programlisting>

      <para>TWO events would be created as there are TWO values associated
      with the %DESTINATION% field name. There is no dependence or interaction
      between the two statements, both are treated as if they were separately
      declared to begin with.</para>

      <programlisting>
DECLARATIVE UDP SRC 5000 DST 192.168.2.102/5001 PERIODIC [1 1024]
DECLARATIVE UDP SRC 5000 DST 192.168.2.103/5001 PERIODIC [1 1024]
</programlisting>
    </sect2>

    <sect2 id="_hostid">
      <title>HOSTID Keyword</title>

      <para>The HOSTID keyword will be translated to the HOSTID assigned in
      the input script. (Note that the HOSTID will be automatically added to
      the dictionary, and any existing HOSTID value will be replaced). The
      functionality facilitates having common script/logictable syntax across
      multiple nodes where appropriate. Dictionary lookups my then be made as
      follows:</para>

      <para>Given HOSTID=63, a dictionary translation of the string:</para>

      <programlisting>
%%HOSTID%FIELD%
</programlisting>

      <para>Would lookup 63FIELD in the dictionary:</para>

      <programlisting>
&lt;name&gt;63FIELD&lt;/name&gt;
&lt;value&gt;FIELD_VALUE&lt;/name&gt;
</programlisting>
    </sect2>

    <sect2 id="Nested_dictionary_translations">
      <title>Nested dictionary translations</title>

      <para>Nested dictionary translations within a field name are supported.
      The value of the nested field will be associated with the non-nested
      field name to lookup the final value(s). Given dictionary entries
      of:</para>

      <programlisting>
&lt;name&gt;NESTED_FIELD&lt;/name&gt;
&lt;value&gt;VALUE_OF_NESTED_FIELD&lt;/value&gt;
&lt;name&gt;VALUE_OF_NESTED_FIELD-NON_NESTED_FIELD&lt;/name&gt;
&lt;value&gt;FINAL_VALUE
</programlisting>

      <para>The script/logictable entry of:</para>

      <programlisting>
%%NESTED_FIELD%-NON_NESTED_FIELD%
</programlisting>

      <para>would be translated as:</para>

      <programlisting>

FINAL_VALUE
</programlisting>
    </sect2>

    <sect2 id="_reserved_namespaces">
      <title>Reserved Namespaces</title>

      <para>Currently the PACKET namespace is reserved for information
      contained in an incoming MGEN packet. Information supported in the
      PACKET namespace includes:</para>

      <itemizedlist>
        <listitem>
           PACKET:SRCIP - Source ip address as defined by the MGEN source field 
        </listitem>

        <listitem>
           PACKET:SRCPORT - Source port as defined by MGEN source field 
        </listitem>

        <listitem>
           PACKET:DSTIP - Destination IP of the MGEN packet 
        </listitem>

        <listitem>
           PACKET:DSTPORT - Destination Port of the MGEN packet 
        </listitem>

        <listitem>
           PACKET:SEED - Random seed stored in the RAPR packet payload 
        </listitem>
      </itemizedlist>

      <programlisting>DECLARATIVE UDP SRC 5000 DST %PACKET:SRCIP%/%PACKET:SRCPORT% PERIODIC [1 2048]
</programlisting>

      <para>The SYSTEM namespace keyword should be used to access the
      RANDOMI(n,n) and RANDOMF(n,n,[z]) functions. These functions will return
      a random integer or a random float value within a specified range. In
      the RANDOMF function, z is an optional argument and specifies the number
      of decimal places the float should have. By default, 1 decimal place is
      generated. For example, the functions at the beginning of a declarative
      declaration:</para>

      <programlisting>%SYSTEM:RANDOMI(5,10)% DECLARATIVE UDP SRC ...
%SYSTEM:RANDOMF(5,10,1)% DECLARATIVE UDP SRC ...
</programlisting>

      <para>would result in a start time between 5 and 10 seconds. The SEED
      associated with the triggering event will be used to seed the random
      number generator used by the random function.</para>

      <para>The SystemNamespace namespace is reserved for application wide
      defaults.</para>
    </sect2>

    <sect2>
      <title>Default Dictionary and Default System Values</title>

      <para>The RAPR application provides certain application wide default
      values. In addition, a "default" dictionary is provided in the RAPR
      distribution that can be used to override these application wide default
      values. If no default dictionary is loaded into a running RAPR
      application via a "LOAD_DICTIONARY" command RAPR will default to using
      the values as specified in the table below. The "dictionary Field"
      columns lists the dictionary field names that <emphasis>must</emphasis>
      be used in the DEFAULT system name space. The "system value" lists the
      internal application wide default that can be overridden in the default
      dictionary.</para>

      <table>
        <title>Default Dictionary</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Dictionary Field</entry>

              <entry align="center">System Value</entry>

              <entry align="center">Comments</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>RETRYINTERVAL</entry>

              <entry>10</entry>

              <entry>The default retry interval used by an interrogative
              object if no RETRYINTERVAL attribute is specified.</entry>
            </row>

            <row>
              <entry>NUMRETRIES</entry>

              <entry>3</entry>

              <entry>The default number of retries used by an interrogative
              object if no NUMRETRIES attribute is specified.</entry>
            </row>

            <row>
              <entry>PATTERN</entry>

              <entry>PERIODIC [1 1024]</entry>

              <entry>The default mgen flow pattern that is used for all
              behavior events when no PATTERN is specified.</entry>
            </row>

            <row>
              <entry>STREAMDURATION</entry>

              <entry>.99</entry>

              <entry>The default stream duration that is used by the
              interrogative object for each message query or as the default
              duration for declarative objects. See the object definitions for
              more details on how this interval is used/calculated.</entry>
            </row>

            <row>
              <entry>PROTOCOL</entry>

              <entry>UDP*</entry>

              <entry>The default protocol to be used by all behavior events.
              Note that this default can <emphasis>only</emphasis> be set in
              the default dictionary. No internal default PROTOCOL is set
              system wide. If no entry is set specified in the default
              dictionary, the PROTOCOL <emphasis>must</emphasis> be set on the
              command line for each behavior event.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>In the default distribution, the default dictionary
      <literal>raprDictionary.xml</literal> is located in the rapr/unix
      directory. By default, the SystemNamespace in this dictionary specifies
      all the attributes listed above. Note that these are the same values
      that will be used by the system even if NO default dictionary is loaded.
      The following is an example of a default dictionary with only the
      default protocol and the number of retries specified. All other defaults
      will revert to those specified internally by the
      application.<programlisting>&lt;RaprDictionary&gt;
    &lt;namespace&gt;
    &lt;label&gt;SystemNamespace&lt;/label&gt;
        &lt;!-- Application wide defaults --&gt;
        &lt;item&gt;
            &lt;!-- Default number of retries for interrogative events --&gt;
            &lt;field&gt;NUMRETRIES&lt;/field&gt;
            &lt;value&gt;5&lt;/value&gt;
        &lt;/item&gt;

        &lt;item&gt;
            &lt;!-- Default protocol for all events --&gt;
            &lt;field&gt;PROTOCOL&lt;/field&gt;
            &lt;value&gt;UDP&lt;/value&gt;
        &lt;/item&gt;
    &lt;/namespace&gt;
&lt;/RaprDictionary&gt;
</programlisting></para>
    </sect2>
  </sect1>

  <sect1 id="_input_script">
    <title>RAPR Input Script Format</title>

    <para>RAPR scripts are text files containing a sequence of commands and
    scheduled events describing traffic generation patterns, ports and/or
    multicast groups to be monitored, and other options. Each line in the
    script corresponds to either a <link linkend="_Rapr_Events">RAPR
    Event</link> (note that many RAPR Events are <link
    linkend="_GLOBAL">Global Events)</link>, or a <link
    linkend="_Reception_Events">Reception Event</link> , or a <link
    linkend="_Behavior_Events">Behavior Event</link>. Lengthy script lines can
    be continued to multiple text file lines by using a trailing backslash '\'
    character at the end of the line. Additionally, blank lines are permitted
    and comment lines can be included by providing a leading '#' character at
    the beginning of lines. (Note comment lines cannot be inserted in between
    "continued" script lines).</para>

    <para>Scheduled events in the script use lines in the format of:</para>

    <programlisting>
[&lt;eventTime&gt;] &lt;eventType&gt; &lt;parameters ...&gt; [&lt;options...&gt;] 
</programlisting>

    <para>These "events" are scheduled to be executed by RAPR at the relative
    time given by the &lt;eventTime&gt; field. The value of this field is a
    floating point number which denotes the relative time (in seconds) of the
    associated event. The time is relative to the start of the RAPR program or
    the time dictated by the <link linkend="_GLOBAL">global</link> START
    command. If the &lt;eventTime&gt; is omitted, an &lt;eventTime&gt; of 0.0
    (or immediately if RAPR is already started) is assumed. <link
    linkend="_Rapr_Events">RAPR Event</link> (or <link
    linkend="_GLOBAL">global commands</link>) are generally used to define
    default behaviors for RAPR operation or other options independent of event
    scheduling.</para>

    <para>The format for global command script lines is: &lt;commandType&gt;
    [&lt;command parameters ...&gt;]</para>
  </sect1>

  <sect1 id="_Behavior_events">
    <title>Behavior Events</title>

    <para>RAPR "Behavior Event" script lines are used to schedule and
    characterize RAPR traffic generation. An instance of RAPR can
    simultaneously transmit traffic to multiple destinations with different
    patterns of transmission. The three main types of behavior events are
    <link linkend="_declarative">Declarative</link>, <link
    linkend="_interrogative">Interrogative</link>, and <link
    linkend="_stream">Stream</link> events.</para>

    <sect2 id="_declarative">
      <title>Declarative Event</title>

      <para>Script syntax:</para>

      <programlisting>
[&lt;eventTime&gt;] [STOP &lt;0.0&gt; | DURATION &lt;0.0&gt;] [RAPRFLOWID &lt;raprFlowId&gt;] 
     DECLARATIVE &lt;protocol&gt; 
     [SRC &lt;srcPort&gt;] 
     DST &lt;dst-ip&gt;/&lt;dstPort&gt; [&lt;validMgenPattern [params]&gt;] 
     [SUCCESS &lt;success_logid_id&gt;] [FAILURE &lt;failure_logic_id&gt;] 
     [PAYLOAD|LOGICID &lt;payload_logic_id&gt;] [TIMEOUT &lt;timeout_logic_id&gt;] 
     [TTL &lt;timetolivevalue&gt;] [TOS &lt;tos&gt;] 
</programlisting>

      <para>The DECLARATIVE keyword directs RAPR to create a behavior event
      that starts either a UDP or a TCP flow to a unicast or multicast
      destination for a given duration and does not expect a response. At the
      specified (or implied) end time it stops the flow.</para>

      <sect3>
        <title>STOP, DURATION, and COUNT attributes.</title>

        <para>The STOP attribute means stop the event (in this instance,
        meaning the mgen flow initiated by the specified mgen pattern) at time
        relative to start time. E.g. if event start time offset was 5.0, a
        STOP 10.0 would stop the event at 10 seconds relative to test start
        time.</para>

        <para>Conversely, the DURATION attribute specifies the duration of the
        event regardless of start offset time. E.g. if the event start offset
        was 5.0, a DURATION 10.0 would stop the event after 10 seconds, at 15
        seconds relative to test start time.</para>

        <para>If no STOP or DURATION is specified, COUNT will default to 1 and
        one message will be sent. If a COUNT <emphasis>is </emphasis>specified
        but no STOP nor DURATION is, the behavior will stop after COUNT *
        pattern interval. If both COUNT and a STOP or DURATION is specified,
        the first limit to be reached will stop the flow.</para>

        <para>Finally, if either STOP or DURATION is set to -1.0 no stop time
        will be set for the flow and the flow will continue indefinately
        unless the flow is subseqently stopped via a RAPRFLOWID command or the
        RAPR</para>
      </sect3>

      <sect3>
        <title>Infinite data flows.</title>

        <para>If either STOP or DURATION is set to -1.0 no stop time will be
        set for the flow and the flow will continue indefinately unless the
        flow is subseqently stopped via a RAPRFLOWID command or the
        RAPR</para>
      </sect3>

      <sect3>
        <title>RAPRFLOWID</title>

        <para>The optional &lt;RAPRFLOWID&gt; is used to identify the flow
        within the script and can be used by a subsequent <link
        linkend="_STOP_Event">STOP</link> event to stop the flow initiated
        here.</para>
      </sect3>

      <sect3>
        <title>SRC, DST, and PATTERN attributes</title>

        <para>The SRC &lt;srcPort&gt;, DST &lt;dstIP&gt;/&lt;dstPort&gt;, and
        mgen PATTERN [&lt;pattern&gt;] attributes are passed through to the
        MGEN engine. (See <ulink
        url="http://www.nrl.navy.mil/itd/ncs/products/mgen">MGEN</ulink> and
        <link linkend="_Behavior_Event_Options">behavior event options</link>
        for additional details on specifying MGEN patterns and these
        attributes). In general however, the &lt;protocol&gt; field indicates
        the transport protocol to be used for the generated RAPR test
        messages.</para>

        <para>Current supported &lt;protocol&gt; types include "UDP" and
        "TCP". The "UDP" protocol type encapsulates generated RAPR messages
        for the flow into UDP/IP packets and transmits them over the network.
        The "TCP" protocol type encapsulates generated RAPR messages for the
        flow into TCP/IP packets and transmits them over the network. Note
        that the destination node must be listening for incoming TCP traffic
        on the specified port. The flow destination address and port must be
        specified using the DST option and the &lt;pattern&gt; of message
        generation must be given as well. Other flow options may be specified
        to further characterize the flow. See <ulink
        url="http://www.nrl.navy.mil/itd/ncs/products/mgen">MGEN</ulink> and
        <link linkend="_Behavior_Event_Options">behavior event options</link>
        for additional information on defining MGEN flow characteristics such
        as TOS and TTL and traffic pattern definitions.</para>
      </sect3>

      <sect3>
        <title>LOGICID, SUCCESS, FAILURE, TIMEOUT, PAYLOAD.</title>

        <para>The SUCCESS, FAILURE, TIMEOUT, and PAYLOAD|LOGICID logic id's
        direct the application behavior upon the specified event. (PAYLOAD and
        LOGICID are synonyms and can be used interchangeably to direct what
        RAPR puts in the message payload field). For DECLARATIVE objects, only
        the SUCCESS and LOGICID|PAYLOAD logic id's have any real meaning.
        After the event stops (e.g. the mgen flow is turned off) any specified
        success id will direct RAPR to perform the behavior specified in the
        <link linkend="_behavior_table">behavior table</link> associated with
        the SUCCESS logic ID. The PAYLOAD logic id (if specified) will be
        placed in the outgoing mgen message payload to direct the target
        node's behavior response to the message(s).</para>

        <para>Examples:</para>

        <para>The simplest declarative command can be written:</para>
      </sect3>

      <sect3>
        <title>Examples</title>

        <para><programlisting>DECLARTIVE DST 192.168.1.100/6000</programlisting>This
        will start a declarative command immediately, direct the system to
        provide a src port, default the flow pattern to "PERIODIC [1 1024]",
        default the COUNT attribute to 1 such that one message will be sent,
        and turn the flow off after that. No logic id will be sent in the
        payload. (Note that if PROTOCOL is not defined in the default
        dictionary PROTOCOL UDP must be specified in the command).</para>

        <para>This script line will originate a "flow" of RAPR UDP destined
        for the loopback address (IP address 127.0.0.1) port number 5000
        beginning immediately when the script is executed. The messages will
        consist of 1024 byte messages at a regular rate of 1.0 per second:
        <programlisting>
0.0 DECLARATIVE UDP SRC 5001 DST 127.0.0.1/5000 PERIODIC [1.0 1024]
</programlisting><para>In this example, no start time is specified so the
        event will take place immediately. No STOP time specified indicates to
        RAPR that a single message should be sent. Upon behavior completion,
        the SUCCESS logic ID directs RAPR to perform the behavior in the <link
        linkend="_behavior_table">behavior table</link> associated with
        SUCCESS id 1. </para><programlisting>
DECLARATIVE UDP SRC 5000 DST 192.168.1.100/5000 PERIODIC [1 1024] SUCCESS 1
</programlisting><para>This command tarts a UDP flow immediately. Stops flow
        10.0 seconds into the test relative to RAPR time. Mgen pattern is
        BURST [REGULAR 10.0 PERIODIC [10.0 256] FIXED 5.0] All UDP messages
        will include a PAYLOAD logic id of 1. </para><programlisting>
0.0 STOP 10.0 DECLARATIVE UDP SRC 5005 DST
192.168.1.100/5005 BURST [REGULAR 10.0 PERIODIC [10.0 256] FIXED 5.0]
LOGICID 1 
</programlisting><para>At 15.0 into test, send a single 5 Meg TCP
        message.</para><programlisting>
15.0 DECLARATIVE TCP SRC 5000 DST 192.168.1.100/5001 [1 5242880] 
#  Declaratives can also be used to trigger an mgen multicast flow
DECLARATIVE UDP SRC  TXBUFFER 2000 DST 224.225.1.2/5001 POISSON [1 4096] 
</programlisting><para>DICTIONARY TRANSLATIONS: Enclose entries in the
        dictionary in "%"'s, e.g. %%. In this example, CMDR1 is translated
        into a RAPR dictionary value (script entries only, not implemented
        over run time interface yet.) </para><programlisting>
DECLARATIVE UDP SRC 5000 DST %CMDR1%/5000 PERIODIC [1 1024] 
</programlisting><para>Mgen pattern is translated into a RAPR dictionary value
        (script entries only, not implemented over run time interface yet.)
        </para><programlisting>
   DECLARATIVE UDP SRC 5000 DST 192.168.1.100/5000 %FLOW_PATTERN_1% 
</programlisting></para>
      </sect3>
    </sect2>

    <sect2 id="_interrogative">
      <title>Interrogative Event</title>

      <para>Script syntax:</para>

      <programlisting>
[&lt;0.0&gt;] [STOP &lt;0.0&gt; | DURATION &lt;0.0&gt;] INTERROGATIVE &lt;protocol&gt; 
     RETRYINTERVAL &lt;retry_interval&gt; 
     NUMRETRIES &lt;#_retries&gt; 
     SRC &lt;srcport&gt; 
     DST &lt;dst-ip&gt;/&lt;dstport&gt; &lt;valid mgen pattern&gt; [COUNT &lt;cnt&gt;]
     [SUCCESS &lt;success_logic_id&gt;] [FAILURE &lt;failure_logic_id&gt;] 
     [PAYLOAD|LOGICID &lt;payload_logic_id&gt;] [TIMEOUT &lt;timeout_logic_id&gt;] 
     [TTL &lt;timetolivevalue&gt;] [TOS &lt;tos&gt;] </programlisting>

      <para>An INTERROGATIVE event sends a single UDP or TCP message or a
      limited mgen flow (as defined by the PATTERN and/or COUNT attributes)
      and waits for a response. If it gets a response from the destination,
      the behavior is considered successful, otherwise not. An INTERROGATIVE
      behavior event can be told to RETRY the behavior N times, at
      RETRYINTERVALS of N, before terminating the behavior. See the <link
      linkend="_declarative">declarative</link> event definition or <link
      linkend="_Behavior_Event_Options">behavior event options</link> for
      details on attributes not detailed here.</para>

      <sect3>
        <title>RETRYINTERVAL and NUMRETRIES</title>

        <para>The RETRYINTERVAL specifies the amount of time to wait before
        sending a subsequent message if a response has not been received from
        the destination. NUMRETRIES specifies how many messages (or limited
        mgen flows) to send to illicit a response from the destination. If no
        behavior end time is specified, the event will time out after the
        number of retries plus one, multiplied by the retry interval.</para>
      </sect3>

      <sect3>
        <title>Stream Duration and COUNT</title>

        <para>Unless the STREAMDURATION attribute is overridden in the <link
        linkend="_DEFAULT_DICTIONARY">default dictionary</link>, the default
        stream duration will be set to 0.99 seconds. This means that there
        will be a one second window within which to send the specified pattern
        of messages, e.g. given a pattern of [10 1024] 10 1024 bytes messages
        will be sent for each interrogative "message"; given a pattern of [1
        1024] 1 1024 byte message will be sent.</para>

        <para>If a COUNT attribute is specified, the STREAMDURATION (the time
        within which the event can send COUNT messages) will be set to the
        RETRYINTERVAL. If the retry interval expires before COUNT messages
        have been sent, the flow will be turned off at retry interval and
        another "retry" of a second set of COUNT messages will be made.</para>
      </sect3>

      <sect3>
        <title>Logic Id's</title>

        <para>The FAILURE logic id, if specified, will direct RAPR to perform
        the behavior specified in the <link linkend="_behavior_table">behavior
        table</link> if a response is not received from the destination before
        the object times out (as dictated by the STOP/DURATION attributes. If
        a message was received from the destination within the time alloted,
        the SUCCESS logic id, if specified, will direct RAPR to perform the
        behavior specified in the <link linkend="_behavior_table">behavior
        table</link>.</para>
      </sect3>

      <sect3>
        <title>Examples</title>

        <para>Examples:</para>

        <para>The simplest interrogative event can be declared as
        follows:</para>

        <programlisting>INTERROGATIVE DST 192.168.1.100/5001 LOGICID 1</programlisting>

        <para>This will cause RAPR to start an interrogative object using the
        application defaults:<programlisting>0.0 STOP 30.0 INTERROGATIVE RETRYINTERVAL 10.0 NUMRETRIES 3 UDP |
SRC &lt;systemProvided&gt; DST 192.168.1.100/50001 \
PERIODIC [1 1024] COUNT 1</programlisting></para>

        <para>The behavior sill start immediately and one 1024 byte UDP
        message will be sent to the destination. The behavior will be repeated
        every 10 seconds. If no response has been received from the
        destination after 4 attempts, the behavior will terminate in a failure
        condition. If a response is received the behavior will be considered
        successful and no further messages will be sent.</para>

        <para>The following command will start an INTERROGATIVE message
        immediately, sending a single UDP message to the destination. After 5
        seconds, if a response has not been received, it will send a 2nd, 3rd,
        and 4th. If after 60 seconds, no response has been received to any of
        the messages, the object will "timeout" and any timeout and/or the
        failure logic IDs will be evaluated. In this case, a failure logic id
        of "5" has been associated with the object, so the object will invoke
        the behavior in the logic table associated with logic id 5. If the
        object HAD received a response, after say, 2 messages had been sent,
        the behavior object would "succeed" and no further action will have
        been taken since the "success" logic id in this example is 0.
        <programlisting>
STOP 60.0 INTERROGATIVE RETRYINTERVAL 5.0 NUMRETRIES 3 UDP SRC 5000 \
DST 192.168.1.100/5001 PERIODIC [1 1024] COUNT 1 FAILURE 5
</programlisting>Assuming no changes have ben made to the default dictionary,
        the following example will send 5 1024 byte TCP messages and one
        second intervals to the destination. If no reply has been received
        after 10 seconds, another burst of 5 tcp messages will be sent and so
        on until the behavior either fails or a successful response has been
        received. <programlisting>INTERROGATIVE TCP DST 192.168.1.100/5000 COUNT 5 </programlisting></para>
      </sect3>
    </sect2>

    <sect2 id="_stream">
      <title>Stream Event</title>

      <programlisting>
Script syntax:
[&lt;eventTime&gt;] [DURATION &lt;duration&gt;] STREAM 
     <link linkend="_RESPPROB">RESPPROB</link> &lt;lowRange&gt; &lt;highRange&gt; 
     [<link linkend="_BURSTPRIORITY">BURSTPRIORITY</link> &lt;burstPriority&gt;] 
     [<link linkend="_BURSTDURATION">BURSTDURATION</link> &lt;burstDuration&gt;] 
     [<link linkend="_BURSTCOUNT">BURSTCOUNT</link> &lt;burstCount&gt;] 
     [<link linkend="_BURSTDELAY">BURSTDELAY</link> &lt;lowDelay&gt; &lt;highDelay&gt;] 
     [<link linkend="_BURSTRANGE">BURSTRANGE</link> &lt;lowRange&gt; &lt;highRange&gt;] 
     [<link linkend="_TIMEOUTINTERVAL">TIMEOUTINTERVAL</link> &lt;timeoutInterval&gt;]&lt;
     PROTOCOL&gt; 
     SRC &lt;srcPort&gt; 
     DST &lt;dstIP&gt;/&lt;dstPort&gt; &lt;mgenPattern&gt; 
     [PAYLOAD|LOGICID &lt;payloadLogicId&gt;] 
</programlisting>

      <para>Stream behavior events can be used to emulate Voice Over IP
      traffic characteristics. The simplest emulation is a "group chat"
      configuration. In this setup, a set of nodes are elected to participate
      in a VOIP group "conversation". One node must be elected to initiate the
      "conversation" and should do so by a scripted STREAM event in its <link
      linkend="_input_script">input script</link> file. Other participating
      nodes must be configured to respond to the initiating node by having
      response STREAM behaviors defined in their <link
      linkend="_behavior_tables">behavior tables</link>. The initiating STREAM
      event must be defined to send a PAYLOAD logic id in its outgoing
      messages to trigger the response behavior(s). All participating nodes
      must <link linkend="_JOIN">JOIN</link> and <link
      linkend="_LISTEN">LISTEN</link> to a common multicast group.</para>

      <sect3 id="_RESPPROB">
        <title>RESPPROB</title>

        <para>Stream messages are sent with a seed that is used by the
        participating nodes to determine whether they should be the next node
        to respond to the "conversation". This incoming seed is used by all
        participating nodes to seed a random number generator. If the next
        random number draw falls within the response probability range
        (RESPPROB &lt;lowRange&gt; &lt;highRange&gt;) defined for a given
        node, the node will be the next to "speak" in the "conversation". Note
        that a triggering node may well be elected "next to respond". The
        response ranges should be equally distributed amongst all nodes
        participating in the "conversation" such that only one node can be
        elected to respond. For example, to set up a group conversation among
        four nodes each with an equal probability of reply, setup the RESPPROB
        attribute as follows:</para>

        <programlisting>... STREAM RESPPROB 0 25 (node A)
... STREAM RESPPROB 26 50 (node B)
... STREAM RESPPROB 51 75 (node C)
... STREAM RESPPROB 76 100 (node D)
</programlisting>
      </sect3>

      <sect3 id="_BURSTDURATION">
        <title>BURSTDURATION</title>

        <para>The BURSTDURATION attribute specifies the length in seconds of
        the node's reply to a "conversation". A reply can be thought of as a
        "burst". This setting may be superseded by the BURSTRANGE
        attribute.</para>
      </sect3>

      <sect3 id="_BURSTCOUNT">
        <title>BURSTCOUNT</title>

        <para>The BURSTCOUNT attribute defines the length of the
        "conversation". A triggering stream with a burst count of 5 will
        result in 5 "bursts" of conversation from any of the participating
        nodes.</para>
      </sect3>

      <sect3 id="_BURSTDELAY">
        <title>BURSTDELAY</title>

        <para>The BURSTDELAY attribute defines the range to be used to
        determine the number of seconds to wait before a node will respond to
        a "conversation" (if so elected based on its response probability).
        For example:</para>

        <programlisting>... STREAM BURSTDELAY 1 3 ...
</programlisting>

        <para>will cause the node to wait between one and three seconds before
        replying.</para>
      </sect3>

      <sect3 id="_BURSTRANGE">
        <title>BURSTRANGE</title>

        <para>The BURSTRANGE attribute defines the range to be used to
        determine the length of the next burst response in number of seconds
        (if so elected based on its response probability). Note that
        BURSTDURATION can also be used to specify the length of burst
        responses. For example:</para>

        <programlisting>... STREAM BURSTRANGE 5 10 ...
</programlisting>

        <para>will cause the node to send a burst response between 5 and 10
        seconds.</para>
      </sect3>

      <sect3 id="_TIMEOUTINTERVAL">
        <title>TIMEOUTINTERVAL</title>

        <para>The TIMEOUTINTERVAL attribute defines the length of time (in
        seconds) that the stream event will wait for response traffic. If no
        response is received from ANY node participating in the conversation
        (including itself) within this timeout interval, the stream object
        will "timeout" and stop the stream event, and not respond to any
        further traffic associated with the stopped "conversation". For
        example:</para>

        <programlisting>... STREAM TIMEOUTINTRERVAL 10  ...
</programlisting>

        <para>will cause the stream event to timeout after 10 seconds.</para>
      </sect3>

      <sect3 id="_BURSTPRIORITY">
        <title>BURSTPRIORITY</title>

        <para>A BURSTPRIORITY can be assigned to STREAM events that will cause
        the "conversation" to take precedence over any other ongoing
        conversation. For example, if a conversation of default priority (0)
        is ongoing, and a second "conversation" is initiated at a higher
        priority, the higher priority conversation will be "served" before the
        lower priority conversation.</para>

        <para>Note that a node can only be "responding" to a single VOIP
        "conversation" at a time. When the response is completed, the node is
        free to participate in other "conversations". If a node is
        participating in a lower priority "conversation", but is not in the
        act of "responding", the node is free to participate in the higher
        priority conversation. If however, the node was responding, or about
        to respond, to a lower priority conversation, the lower priority
        conversation will be "stopped" potentially causing the end of the
        first conversation. If enough packets have been received by the
        participating nodes to trigger the next "burst" of conversation
        however, this may not be the case. For example, Node X starts stream
        conversation 1, sequence # 1 (where node X refers to all the possible
        nodes participating in a group chat)</para>

        <programlisting>        node X 1.1&gt; node B (node b responds to stream 1, w/burst 2)
                  &lt;1.2
                  &lt;1.2
                  &lt;1.2
</programlisting>

        <para>Node C requests a higher priority conversation while node b is
        responding to conversation 1. Node B, stops stream 1.2 and responds to
        2.1</para>

        <programlisting>        node C 2.1&gt; node B 
                  &lt;OFF 1.2
                  &lt;2.2
                  &lt;2.2
        
        node C 2.3&gt; node B
               2.3&gt;
</programlisting>

        <para>Meanwhile the node in conversation 1 that was chosen to respond
        to sequence 1.2 starts responding (because it received a triggering
        packet - given 0% packet loss, just a single packet will trigger the
        response. The responding node does not know, nor needs to know that
        node b has - perhaps temporarily - dropped out). Node B hears this
        traffic but is not elected to respond based on the probability of
        response. It will passively ignore this conversation and continue to
        respond to node C (assuming set up to direct this behavior in the
        stream configuration)</para>

        <programlisting>        node X 1.3&gt; node B
                          (probability of response = false, do nothing)
        
                           node X.1 probability of response = true, responds
                  &lt;1.4 node X.1 
        
           node C &lt;2.4 node B
                  &lt;2.4             * conversation ends
</programlisting>

        <para>Node X.1 responded to 1.3, and its 1.4 response will direct node
        b to respond. Because 1) node b is not speaking in any other
        conversations, and because 2) the conversation with node C is
        completed, node b "rejoins" conversation 1.</para>

        <programlisting>        node X.1 1.4&gt; node B (probabiliyt of response = true, continue)
                    &lt;1.5
                    &lt;1.5
</programlisting>

        <para>Note that if it was node B's turn to respond to 1.3 and node B
        is unable to do so due to the higher priority conversation,
        conversation 1 will end sooner than scheduled.</para>
      </sect3>
    </sect2>

    <sect2 id="_periodic">
      <title>Periodic Event</title>

      <para>Script syntax:</para>

      <programlisting>&lt;eventTime&gt;[STOP &lt;0.0&gt; | DURATION &lt;0.0&gt;] [RAPRFLOWID &lt;raprFlowId&gt;] 
     PERIODIC 
     <link linkend="_INTERVAL">INTERVAL</link> &lt;interval&gt; [EXP]
     <link linkend="_DURATION">DURATION</link> &lt;duration&gt; 
     &lt;<link linkend="_description">Declarative/Interrogative Description</link>&gt; 
</programlisting>

      <para>Periodic Events can be used to spawn other behavior event types
      (Declarative and Interrogative only) at regular intervals. These
      generated behavior events behave as independent events and have no
      relationship to one another. In the following example, the event will
      start at time 0.0 in the timeline and spawn an initial DECLARATIVE event
      at time 0.0 that will send a single UDP message (e.g. timeout at time
      0.01). After an 5 second interval, a second UDP message will start and
      timeout after 0.01. After 30 seconds, the periodic object will timeout
      after spawning six declarative objects at 5 second intervals.</para>

      <programlisting>0.0 STOP 30.0 RAPRFLOWID 1 PERIODIC INTERVAL 5 DURATION 0.01 \
DECLARATIVE UDP SRC 5000 DST 192.168.1.102/5001 PERIODIC [1 1024]
</programlisting>

      <para>In this example, the command would direct RAPR to start a
      PERIODICITY object associated with RAPRFLOWID "1" 15 seconds into the
      test and have it run for 15 seconds, kicking off the behavior at 5
      second intervals. At 15 seconds into the test, an interrogative object
      would be created that behaves as a normal interrogative object would.
      The interrogative object would have a five second duration and send four
      messages at 1 second intervals before timing out after 5 seconds, if no
      response message has been received.</para>

      <para>After 5 seconds (regardless of the state of the first "behavior"
      instantiated), the periodic object will instantiate a new interrogative
      object, and for 5 second intervals thereafter, up to the 15 second
      "timeout" period.</para>

      <programlisting>15.0 STOP 30.0 RAPRFLOWID 1 PERIODIC INTERVAL 5 DURATION 5.0 
   INTERROGATIVE RETRYINTERVAL 1.0 NUMRETRIES 3 UDP SRC 5001 \
DST 192.168.1.102/5000 PERIODIC [1 1024] LOGICID 1 
</programlisting>

      <note>
        <para>The periodicity object will retranslate its event definition for
        the object to be spawned each time a new object starts. The PERIODIC
        INTERVAL is also retranslated each time. For example, the following
        PERIODIC definition will send a single 1024 byte UDP packet to
        192.168.1.102 every 5 to 10 seconds for 120 seconds.</para>
      </note>

      <programlisting>DURATION 120 PERIODIC INTERVAL %SYSTEM:RANDOMI(5,10)% DECLARATIVE \
UDP DST 192.168.1.102/6000</programlisting>

      <note>
        <para>Translations that would result in multiple objects being created
        will ~not~ be allowed. E.g.</para>

        <para>STOP 30 PERIODIC INTERVAL 10 DECLARATIVE DST %DESTINATION%
        &lt;item&gt; &lt;field&gt;DESTINATION&lt;/field&gt;
        &lt;value&gt;192.168.1.102&lt;/value&gt;
        &lt;value&gt;192.168.1.103&lt;/value&gt; &lt;/item&gt; A warning
        message would be displayed that periodicity behavior definitions
        cannot result in multiple events being created.</para>
      </note>

      <note>
        <para>Note that the STOP or DURATION attribute must be specified for
        periodic events and that the RAPRFLOWID attribute must follow the STOP
        OR DURATION attribute.</para>
      </note>

      <sect3 id="_INTERVAL">
        <title>INTERVAL</title>

        <para>The INTERVAL keyword specifies the interval at which new <link
        linkend="_declarative">declarative</link> or <link
        linkend="_interrogative">interrogative</link> events should be
        instantiated. The first event will be spawned at the start time of the
        periodic object itself, the second after the INTERVAL has elapsed.
        Events will continue to be spawned at this regular interval until the
        periodic event times out or is stopped by a <link
        linkend="_raprflowid">RAPRFLOWID</link> command.</para>
      </sect3>

      <sect3>
        <title>EXP</title>

        <para>The EXP keyword directs RAPR to calculate the interval at which
        the periodic object spawns other events following a POISSON
        distribution, or at an exponentially distributed interval. Note that
        this may cause object/traffic overlap should the calculated spawning
        interval be smaller that the spawned object(s) duration(s).</para>
      </sect3>

      <sect3 id="_DURATION">
        <title>DURATION</title>

        <para>The DURATION command specifies the duration of the spawned
        events. STOP is not a valid attribute for the spawned events.</para>
      </sect3>

      <sect3 id="_description">
        <title>Declarative/Interrogative Description</title>

        <para>See <link linkend="_declarative">declarative</link> and <link
        linkend="_interrogative">interrogative</link> events for the required
        patterns. Note that STOP is not a valid attribute when these events
        are to be triggered by a Periodic event.</para>
      </sect3>
    </sect2>

    <sect2 id="_Behavior_Event_Options">
      <title>Behavior Event Options</title>

      <para>This section describes options which may be applied to <link
      linkend="_Behavior_Events">behavior</link> events in RAPR script files.
      Note that transmission events (e.g. DECLARATIVE, INTERROGATIVE, and
      STREAM events) require specification of at least the &lt;protocol&gt;,
      &lt;destination&gt;, and &lt;pattern&gt; options.</para>

      <sect3 id="Protocol__UDP">
        <title>Protocol (UDP)</title>

        <para><literal> Option syntax: ... &lt;protocolType&gt; ... </literal>
        The transport protocol for RAPR messages generated by a flow must be
        specified as part of any events. Example:</para>

        <programlisting>DECLARATIVE UDP DST 127.0.0.1/5000 PERIODIC [1.0 1024] </programlisting>
      </sect3>

      <sect3 id="_Destination__DST">
        <title>Destination (DST)</title>

        <para><literal> Option syntax: ... DST &lt;addr&gt;/&lt;port&gt; ...
        </literal> The destination address for a flow must be specified. The
        &lt;addr&gt; field specifies the destination IP address (IPv4 or IPv6)
        and the &lt;port&gt; field specifies the destination host port number.
        The destination address may be a unicast (point-to-point) or multicast
        address. Examples:</para>

        <programlisting>#Start a flow to loopback address
port 50000.0 DECLARATIVE UDP DST 127.0.0.1/5000 PERIODIC [1.0 1024]
</programlisting>
      </sect3>

      <sect3 id="_Source_Port__SRC">
        <title>Source Port (SRC)</title>

        <para><literal> Option syntax: ... SRC &lt;port&gt; ... </literal> The
        source port number used for generated traffic may be optionally
        specified. The &lt;port&gt; field identifies the host port number to
        be used. When the SRC option is not specified, the flow will use a
        free port number picked by the operating system. Note that RAPR UDP
        flows may share the same source port and the associated flow will
        "inherit" some attributes (e.g. <link
        linkend="_Type-Of-Service_(TOS)">TOS</link>, <link
        linkend="_Time-To-Live_(TTL)">TTL</link>, etc) which may have been set
        for other flows which use that same source port. This is because some
        of these attributes tend to be maintained by operating systems on a
        "per socket" basis. Also, any such attributes set for this flow will
        affect other existing flows using the same source port. Thus, the SRC
        option is useful when it is desired to explicitly create different
        flows with distinct "per socket" attributes such as <link
        linkend="_Type-Of-Service_(TOS)">TOS</link> or multicast <link
        linkend="_Time-To-Live_(TTL)">TTL</link>.</para>

        <para>Example: Here, two flows are created with the same destination
        address, but different source ports. Flow 1 is also assigned
        non-default type-of-service using the <link
        linkend="_Type-Of-Service_(TOS)">TOS</link> option. The use of the SRC
        option ensures that two different sockets are used to support the two
        different types of service.</para>

        <programlisting><literal>
#Start flow 1 using source port 5001(TOS = 0x10) 
#and flow 2 using port 5002 
0.0 DECLARATIVE UDP DST 127.0.0.1/5000 SRC 5001 PERIODIC [1.0 1024] TOS \
0x100.0 
DECLARATIVE UDP DST 127.0.0.1/5000 SRC 5002 PERIODIC [10.0 512] 
</literal>
</programlisting>
      </sect3>

      <sect3 id="Pattern__PERIODIC,_POISSON,_BURST">
        <title>Pattern (PERIODIC, POISSON, BURST)</title>

        <para><literal> Option syntax: ... &lt;patternType&gt; [parameters
        ...] ... </literal> (Note: The '[' and ']' characters are explicitly
        required at the beginning and end of the pattern parameter set.
        Different pattern types may use different parameter sets.) Traffic
        generated by RAPR consists of a series of sequence-numbered messages.
        The messaging generated by RAPR may vary in size and frequency of
        transmission to stress the network in a controlled fashion. The
        "Pattern" of message generation must be specified. Currently RAPR/MGEN
        supports three pattern types, "PERIODIC", "POISSON", and "BURST".
        Complex traffic patterns can be created by using a compound of
        multiple "flows" (with the same <link
        linkend="_Source_Port_(SRC)">SRC</link>/<link
        linkend="_Destination_(DST)">DST</link>) with different pattern types
        and parameters. Other pattern types (e.g. MARKOV), including ones with
        statistically varying payload sizes, will be added eventually.</para>

        <sect4 id="PERIODIC_Pattern">
          <title>PERIODIC Pattern:</title>

          <para><literal> Option syntax: ... PERIODIC [&lt;rate&gt;
          &lt;size&gt;] ... </literal> This pattern type generates messages of
          a fixed &lt;size&gt; (in bytes) at a very regular &lt;rate&gt; (in
          messages/second). The &lt;size&gt; field must be greater or equal to
          the minimum RAPR message size and less than or equal to the maximum
          UDP message size of 8192 bytes. When other transport support is
          added (e.g. TCP), the message &lt;rate&gt; and &lt;size&gt;
          parameters will have additional flexibility as appropriate. Note the
          &lt;rate&gt; must be greater than or equal to 0.0 messages/second.
          Example:</para>

          <programlisting>
#Start an RAPR flow sending 1024 byte messages 
#at a rate of 10.0 per second 
0.0 DECLARATIVE UDP DST 127.0.0.1/5000 PERIODIC [10.0 1024] 
#Reduce the flow rate to one 512 byte message
#every 2.0 seconds 
0.0 DECLARATIVE PERIODIC [0.5 512]
</programlisting>
        </sect4>

        <sect4 id="POISSON_Pattern">
          <title>POISSON Pattern:</title>

          <para><literal> Option syntax: ... POISSON [&lt;aveRate
          (msg/sec)&gt; &lt;size (bytes)&gt;] ... </literal> This pattern type
          generates messages of a fixed &lt;size&gt; (in bytes) at
          statistically varying intervals at an average &lt;rate&gt; (in
          messages/second). The &lt;size&gt; field must be greater or equal to
          the minimum RAPR message size and less than or equal to the maximum
          UDP message size of 8192 bytes. When other transport support is
          added (e.g. TCP), the message &lt;aveRate&gt; and &lt;size&gt;
          parameters will have additional flexibility as appropriate. Note the
          &lt;rate&gt; must be greater than or equal to 0.0 messages/second.
          Example:</para>

          <programlisting>#Start an RAPR flow sending 1024 byte messages 
#at an average rate of 10.0 per second 
0.0 DECLARATIVE UDP DST 127.0.0.1/5000
POISSON [10.0 1024] #Reduce the flow rate to an average of one 
#512 byte message every 2.0 seconds 
0.0 DECLARATIVE POISSON [0.5 512]
</programlisting>
        </sect4>

        <sect4 id="_BURST_pattern">
          <title>BURST Pattern:</title>

          <para><literal> Option syntax: ... BURST [REGULAR|RANDOM
          &lt;aveInterval (sec)&gt; &lt;patternType&gt;
          [&lt;patternParams&gt;] FIXED|EXPONENTIAL &lt;aveDuration (sec)&gt;]
          ... </literal> The BURST pattern generates bursts of other RAPR
          pattern types at a specified average interval. The first parameter
          of the BURST pattern is either "REGULAR" resulting in periodic burst
          uniformly distributed in time by the &lt;aveInterval&gt; value, or
          "RANDOM" which exponentially distributes the traffic generation
          bursts in time with an average burst interval as specified by the
          &lt;aveInterval&gt; parameter value.</para>

          <para>The characteristics of the RAPR messages generated during a
          burst is given by the &lt;patternType&gt; and associated
          &lt;patternParams&gt; parameters. The &lt;patternType&gt; may any
          RAPR pattern type including PERIODIC, POISSON, or, yes, even BURST.
          The &lt;patternParams&gt; must be appropriate for the given
          &lt;patternType&gt;.</para>

          <para>When a traffic generation burst occurs, its duration is either
          of a FIXED value as given by the &lt;aveDuration&gt; or a randomly
          varying duration with EXPONENTIAL statistics and an average duration
          as given by the &lt;aveDuration&gt; parameter.</para>

          <para>An example use of the BURST pattern would be to roughly
          emulate the "talk spurts" which might result from Voice Over IP
          (VOIP) applications. As a voice conversation commences, a user's
          burst of activity (talk spurts) might be RANDOM with some average
          interval and the duration of the talk spurts might approximate
          EXPONENTIAL statistics. When the talk spurt (burst) occurs, the
          voice compression codec might generate messages following something
          like a PERIODIC flow with packet rates and packet sizes dependent
          upon the voice codec in use.</para>

          <para>Other uses of the BURST pattern might be to roughly model
          message/packet generation occurring with random use of a network
          such as web browsing, etc. The BURST model provided by RAPR does not
          presuppose any specific traffic model, but might be useful in
          approximating some models of regular or intermittent network
          activity. The average traffic generation rate for this pattern
          should be approximately the average transmission rate of the core
          &lt;patternType&gt; and &lt;patternParams&gt; multiplied by the
          burst duty cycle (&lt;aveDuration&gt; / &lt;aveInterval&gt;). Note
          that when average burst duration tends to exceed the average burst
          interval, the flow will tend to follow the characteristics of the
          core pattern (i.e. 100% duty cycle).</para>

          <para>Example:</para>

          <programlisting>#Start a bursty RAPR flow with bursts of 1024 byte messages 
#with a periodic rate of 10.0 messages per second.  The 
#bursts will occur at random intervals with an average 
#interval from the start of one burst until the start of 
#the next of 10.0 seconds.  The duration of each burst is
#of exponential statistics with an average burst duration 
#of 5.0 seconds.  
0.0 DECLARATIVE UDP DST 127.0.0.1/5000 BURST [RANDOM 10.0 \
PERIODIC [10.0 1024] EXP 5.0] </programlisting>
        </sect4>
      </sect3>

      <sect3 id="_Destination__DST">
        <title>Count</title>

        <para><literal>Option syntax: ... COUNT &lt;cnt&gt; ... </literal> The
        optional COUNT attribute specifies the number of messages that are to
        be sent for the event, e.g. a COUNT value of 1 means that one and only
        one mgen message will be sent. If no stop time is specified, COUNT
        attribute is defaulted to a value of 1.</para>

        <para>Example:</para>

        <programlisting># Start a declarative message and send 3 messages before exiting
# according to the specified pattern:
DECLARATIVE DST 127.0.0.1/5000 PERIODIC [1 1024] COUNT 3 </programlisting>

        <para>To send 5 messages every 2 seconds:</para>

        <programlisting>declarative UPD src 5000 dst 192.168.1.100/6000 \
PERIODIC [.5 512] COUNT 5</programlisting>

        <para>Note that if both COUNT and an event STOP time are provided,
        whichever parameter stops the flow soonest will win out. E.g. if COUNT
        packets are sent before the STOP event is processed, the flow will be
        stopped; if the STOP time is reached before COUNT packets are sent,
        the flow will be stopped.</para>

        <programlisting># This declarative behavior event flow will be stopped after
# five seconds
STOP 5.0 DECLARATIVE DST 127.0.0.1/6000 PERIODIC [1 1024] COUNT 10

# This declarative behavior event flow will be stopped after
# 5 packets have been sent
STOP 10.0 DECLARATIVE DST 127.0.0.1/6000 PERIODIC [1 1024] COUNT 5
</programlisting>
      </sect3>

      <sect3 id="Type-Of-Service__TOS">
        <title>Type-Of-Service (TOS)</title>

        <para><literal> Option syntax: ... TOS &lt;value&gt; ... </literal>
        The IP TOS (type-of-service) field can be controlled for IP packets
        associated with RAPR traffic generation. The &lt;value&gt; field
        specifies the value of the 8-bit TOS field in IPv4 packets. (IPv6
        packets do not have a TOS field. RAPR will soon support control of the
        similar FLOW_ID field for IPv6 operation.) The &lt;value&gt; field
        must be in the range of 0-255 in decimal or hexadecimal
        notation.</para>

        <para>The interpretation of the TOS value by different computer
        operating systems and network devices may vary. In some cases,
        computer hosts will not allow all possible values to be used, and in
        others "super user" (root) privileges may be required to set the IP
        TOS field to certain values.</para>

        <para>Below are some notes on suggested interpretation by the Internet
        Engineering Task Force (IETF). Note that TOS is maintained on a "per
        socket" basis and that setting the TOS for a flow will affect other
        flows sharing the same network socket. See the <link
        linkend="_Source_Port_(SRC)">SRC</link> option to make sure different
        flows use different sockets.</para>

        <para>Example:</para>

        <programlisting>#Start flow 1 with default TOS 
0.0 ON 1 UDP DST 127.0.0.1/5000 PERIODIC [1.0 1024] 

#Modify flow 1 to TOS = 0x10 (low delay) 
5.0 MOD 1 TOS 0x10 </programlisting>

        <programlisting> 
<?dbfo keep-together="always" ?> 
<literal>   0     1     2     3     4     5     6     7
+-----+-----+-----+-----+-----+-----+-----+-----+ 
|   PRECEDENCE    | TOS |         MBZ           | 
+-----+-----+-----+-----+-----+-----+-----+-----+ 
</literal>
</programlisting>

        <para>The Type-of-Service byte in the IP header is divided into three
        sections: the Precedence field (high-order 3 bits), a field that is
        called Type of Service or TOS (next 4 bits), and a reserved bit (the
        low order bit). The TOS bits can be set to 5 different settings
        including the default setting of 0000, while the PRECEDENCE can be set
        to 8 different setting including default 000. TOS definitions:</para>

        <informaltable>
          <tgroup cols="4">
            <tbody>
              <row>
                <entry/>

                <entry>IPTOS_TOS_MASKIPTOS_TOS(tos)</entry>

                <entry>0x1E= ((tos) &amp; IPTOS_TOS_MASK)</entry>
              </row>

              <row>
                <entry>1000 --</entry>

                <entry>IP_TOS_LOWDELAY</entry>

                <entry>0x10</entry>

                <entry>TOS = 16</entry>
              </row>

              <row>
                <entry>0100 --</entry>

                <entry>IP_TOS_THROUGHPUT</entry>

                <entry>0x08</entry>

                <entry>TOS = 8</entry>
              </row>

              <row>
                <entry>0010 --</entry>

                <entry>IPTOS_RELIABILITY</entry>

                <entry>0x04</entry>

                <entry>TOS = 4</entry>
              </row>

              <row>
                <entry>0001 --</entry>

                <entry>IPTOS_LOWCOST</entry>

                <entry>0x02</entry>

                <entry>TOS = 2</entry>
              </row>

              <row>
                <entry>0000 --</entry>

                <entry>normal service</entry>

                <entry>0x00</entry>

                <entry>TOS = 0</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Precedence definitions:</para>

        <informaltable>
          <tgroup cols="4">
            <tbody>
              <row>
                <entry>111 --</entry>

                <entry>IPTOS_PREC_MASKIPTOS_PREC(tos)</entry>

                <entry>0xe0= ((tos) &amp; IPTOS_PREC_MASK)</entry>
              </row>

              <row>
                <entry>111 --</entry>

                <entry>IPTOS_PREC_NETCONTROL</entry>

                <entry>0xe0</entry>

                <entry>TOS = 224</entry>
              </row>

              <row>
                <entry>110 --</entry>

                <entry>IPTOS_PREC_INTERNETCONTROL</entry>

                <entry>0xc0</entry>

                <entry>TOS = 192</entry>
              </row>

              <row>
                <entry>101 --</entry>

                <entry>IPTOS_PREC_CRITIC_ECP</entry>

                <entry>0xa0</entry>

                <entry>TOS = 160</entry>
              </row>

              <row>
                <entry>100 --</entry>

                <entry>IPTOS_PREC_FLASHOVERRIDE</entry>

                <entry>0x80</entry>

                <entry>TOS = 128</entry>
              </row>

              <row>
                <entry>011 --</entry>

                <entry>IPTOS_PREC_FLASH</entry>

                <entry>0x60</entry>

                <entry>TOS = 96</entry>
              </row>

              <row>
                <entry>010 --</entry>

                <entry>IPTOS_PREC_IMMEDIATE</entry>

                <entry>0x40</entry>

                <entry>TOS = 64</entry>
              </row>

              <row>
                <entry>001 --</entry>

                <entry>IPTOS_PREC_PRIORITY</entry>

                <entry>0x20</entry>

                <entry>TOS = 32</entry>
              </row>

              <row>
                <entry>000 --</entry>

                <entry>IPTOS_PREC_ROUTINE</entry>

                <entry>0x00</entry>

                <entry>TOS = 0</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>If TOS = 164 (or 0xa4), the Precedence would be
        IPTOS_PREC_CRITIC_ECP and the TOS would be IPTOS_RELIABILITY. The IP
        TOS field bits would be set as 10100100.</para>
      </sect3>

      <sect3 id="_Time-To-Live__TTL">
        <title>Multicast Time-To-Live (TTL)</title>

        <para><literal> Option syntax: ... TTL &lt;value&gt; ... </literal>
        The time-to-live (TTL) hop count can be controlled for IP multicast
        traffic generated by RAPR. As with <link
        linkend="_Type-Of-Service_(TOS)">TOS</link>, this is generally a "per
        socket" attribute and care should be taken if it is desired to specify
        different TTL values for different RAPR flows. This can be
        accomplished by using different <link
        linkend="_Source_Port_(SRC)">SRC</link> (source ports) for different
        RAPR flows. The &lt;value&gt; field must be in the range of 1-255. The
        default multicast TTL assumed by RAPR is 3. Example:</para>

        <programlisting>#Start an IP multicast flow with a maximum hop count ttl = 2
0.0 ON 1 UDP DST 224.1.2.3/5000 PERIODIC [1.0 256] TTL 2
</programlisting>
      </sect3>

      <sect3 id="_TXBUFFER">
        <title>Socket Transmit Buffer Size (TXBUFFER)</title>

        <para><literal> Option syntax: ... TXBUFFER &lt;txBufferSize&gt; ...
        </literal> This option allows users to set the socket transmit buffer
        size to a value Òat leastÓ as large as &lt;txBufferSize&gt;. If
        &lt;txBufferSize&gt; is larger that the maximum allowed by the system,
        &lt;txBufferSize&gt; will be set to the system maximum. To date, this
        option has only been tested on linux systems.</para>
      </sect3>

      <sect3 id="Socket_Receive_Buffer_Size__RXBUFFER">
        <title>Socket Receive Buffer Size (RXBUFFER)</title>

        <para><literal> Option syntax: ... RXBUFFER &lt;rxBufferSize&gt; ...
        </literal> This option allows users to set the socket receive buffer
        size to a value Òat leastÓ as large as &lt;rxBufferSize&gt;. If
        &lt;rxBufferSize&gt; is larger that the maximum allowed by the system,
        &lt;rxBufferSize&gt; will be set to the system maximum. To date, this
        option has only been tested on linux systems.</para>
      </sect3>

      <sect3 id="Multicast_Interface__INTERFACE">
        <title>Multicast Interface (INTERFACE)</title>

        <para><literal> Option syntax: ... INTERFACE &lt;interfaceName&gt; ...
        </literal> The network interface to use for IP multicast flow
        transmission can be controlled with this option. The
        &lt;interfaceName&gt; is the network interface device name to be used
        for IP multicast transmission for the associated flow. Again, as with
        <link linkend="_Type-Of-Service_(TOS)">TOS</link> and <link
        linkend="_Multicast_Time-To-Live_(TTL)">TTL</link>, this is generally
        a "per socket" attribute and care should be taken if it is desired to
        specify different multicast interfaces for different RAPR flows. This
        can be accomplished by using different <link
        linkend="_Source_Port_(SRC)">SRC</link> (source ports) for different
        RAPR flows. If no INTERFACE option is used, RAPR will behave according
        to the operating system's default behavior. Example:</para>

        <programlisting>
#Start an IP multicast flow on Ethernet interface named "eth1"
0.0 DECLARATIVE UDP DST 224.1.2.3/5000 PERIODIC [1.0 256] INTERFACE \
eth1 SRC 5001
</programlisting>
      </sect3>
    </sect2>

    <sect2 id="_Reception_Event">
      <title>Reception Events</title>

      <para>For simple reception and logging of unicast traffic, it is
      generally sufficient just to launch RAPR with the port command line
      option specifying the port numbers to monitor. However, for IP multicast
      operation or more complex behavior, a RAPR script with "Reception
      Events" is required. "Reception Events" in the RAPR script file format
      include <link linkend="_LISTEN">LISTEN</link> types to control which
      ports are being monitored when; and <link linkend="_JOIN">JOIN</link>
      types to dynamically control IP group membership. The RAPR script syntax
      of "Reception Events" is:</para>

      <programlisting>
&lt;eventTime&gt; [STOP &lt;stopTime&gt; | DURATION &lt;duration&gt;] &lt;eventType&gt; \
&lt;parameters ...&gt; [&lt;options ...&gt;]
</programlisting>

      <sect3 id="_LISTEN">
        <title>LISTEN</title>

        <programlisting>Script syntax:
&lt;eventTime&gt; [STOP &lt;stopTime&gt; | DURATION &lt;duration&gt;] LISTEN &lt;protocol&gt; \
&lt;portList&gt;
</programlisting>

        <para>The LISTEN event is used to prompt RAPR to begin monitoring one
        or more ports for received traffic. The &lt;eventTime&gt; denotes the
        time (in seconds) relative to script execution. The &lt;protocol&gt;
        field specifies the transport protocol type. Supported protocol types
        include "UDP" and "TCP" transport. The &lt;portList&gt; field is a
        comma-delimited list of individual or inclusive ranges of the port
        numbers (no spaces allowed) to begin monitoring. Port ranges within
        the list are specified in the format
        "&lt;lowValue&gt;-&lt;hiValue&gt;". RAPR will IGNORE the listened to
        port when the timeout interval for the reception event has elapsed.
        Example:</para>

        <programlisting>
#Monitor port numbers 5000,5003,5004,5005,5009
#beginning at time 0.0

0.0 LISTEN UDP 5000,5003-5005,5009

</programlisting>
      </sect3>

      <sect3 id="_JOIN">
        <title>JOIN</title>

        <programlisting>
Script syntax:
&lt;eventTime&gt; [STOP &lt;stopTime&gt; | DURATION &lt;duration&gt;] JOIN &lt;groupAddress&gt; \
[INTERFACE &lt;interfaceName&gt;] [PORT &lt;portNumber&gt;]
</programlisting>

        <para>The JOIN event is used to prompt RAPR to "join" the specific IP
        multicast group indicated by the &lt;groupAddress&gt; field. The
        INTERFACE option forces the membership join request on the network
        interface identified by the &lt;interfaceName&gt; field. If no
        INTERFACE option is given, the operating system's default behavior is
        observed. Note it is possible to join the same group on multiple,
        different interfaces. Note that a corresponding <link
        linkend="_LISTEN">LISTEN</link> event for the indicated
        &lt;portNumber&gt; is required in order to receive traffic. Unix-based
        operating systems generally allow for IP multicast group membership to
        be independent of specific socket port bindings. RAPR will
        automatically LEAVE the specific IP multicast group indicated by the
        &lt;groupAddress&gt; field when the timeout period for the event has
        elapsed.&gt;/p&gt; As many IP group memberships as the operating
        system will support is permitted by RAPR. This is generally a limit of
        the maximum number of open sockets per process or in the system at
        large if multiple RAPR instances are used. Note that Unix-based
        systems can allow for many memberships (often 20, but OS-specific) per
        socket. <para> Examples: </para> <programlisting>#JOIN group 224.1.2.3 at time 0.0
0.0 JOIN 224.1.2.3

#JOIN group 224.1.2.4 on interface "eth1"
0.0 JOIN 224.1.2.4 INTERFACE eth1

#JOIN group 224.1.2.5 using socket bound to port 5000
0.0 JOIN 224.1.2.5 PORT 5000
</programlisting></para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="_Rapr_Events">
    <title>Rapr Events and Global Commands</title>

    <para>The RAPR script file format supports a subset of commands which are
    independent of normal transmission and reception event scheduling. They
    set global parameters for the system (such as setting a default TTL for
    all outgoing packets) or direct rapr application behavior (such as
    specifying an absolute script execution start time, changing application
    state, or loading a dictionary file) . These are referred to as <link
    linkend="_RAPR_EVENTS">Rapr Events</link> and <link
    linkend="_GLOBAL">Global Commands</link>. Global Commands are those that
    can be specified at the command line upon rapr startup.</para>

    <sect2 id="_RAPR_EVENT">
      <title>RaprEvents</title>

      <para>The set of "Rapr Events" includes:</para>

      <itemizedlist>
        <listitem>
          <link linkend="_raprpipe">RAPRPIPE</link>
        </listitem>

        <listitem>
          <link linkend="_stop">STOP</link>
        </listitem>

        <listitem>
          <link linkend="_raprflowid">RAPRFLOWID</link>
        </listitem>

        <listitem>
          <link linkend="_dictionary_entry">DICTIONARY_ENTRY</link>
        </listitem>

        <listitem>
          <link linkend="_logictable_file">LOGICTABLE_FILE</link>
        </listitem>

        <listitem>
          <link linkend="_dictionary_file">DICTIONARY_FILE</link>
        </listitem>

        <listitem>
          <link linkend="_change_state">CHANGE_STATE</link>
        </listitem>

        <listitem>
          <link linkend="_change_ubi_state">CHANGE_UBI_STATE</link>
        </listitem>

        <listitem>
          <link linkend="_logicid">LOGICID</link>
        </listitem>

        <listitem>
          <link linkend="_input">INPUT</link>
        </listitem>

        <listitem>
          <link linkend="_clear">CLEAR</link>
        </listitem>
      </itemizedlist>

      <sect3 id="_raprflowid">
        <title>RAPRFLOWID</title>

        <para><literal> Script syntax: &lt;eventTime&gt; RAPRFLOWID
        &lt;raprFlowId&gt; </literal> The RAPRFLOWID keyword directs rapr to
        stop the <link linkend="_Behavior_Events">behavior event</link> that
        has been previously associated with the &lt;raprFlowId&gt;. The event
        will be stopped at the specified start time.</para>

        <programlisting>5.0 STOP RAPRFLOWID &lt;raprFlowId&gt;

</programlisting>
      </sect3>

      <sect3 id="_dictionary_entry">
        <title>DICTIONARY_ENTRY</title>

        <para><literal> Script syntax: &lt;eventTime&gt; DICTIONARY_ENTRY
        &lt;dictionaryName&gt; [&lt;dictionaryValue&gt;] </literal> The
        DICTIONARY_ENTRY keyword directs RAPR to replace the <link
        linkend="_dictionary">dictionary</link> entry that has been previously
        associated with the specified &lt;name&gt; with the provided
        &lt;value&gt;. The event will take place at the specified start time.
        The dictionary &lt;value&gt; must be enclosed in brackets.</para>

        <programlisting>
5.0 DICTIONARY_ENTRY IP [127.0.0.1]
</programlisting>
      </sect3>

      <sect3 id="_logictable_file">
        <title>LOGICTABLE_FILE</title>

        <para><literal> Script syntax: &lt;eventTime&gt; LOGICTABLE_FILE
        &lt;fileName&gt; </literal> The LOGICTABLE_FILE keyword directs RAPR
        to load the <link linkend="_behavior_table">behavior table</link> of
        the specified &lt;name&gt; at the specified start time. Either a fully
        qualified path or a relative path name may be specified.</para>

        <programlisting>
5.0 LOGICTABLE_FILE /home/rapr/logictable.xml
</programlisting>
      </sect3>

      <sect3 id="_dictionary_file">
        <title>DICTIONARY_FILE</title>

        <para><literal> Script syntax: &lt;eventTime&gt; DICTIONARY_FILE
        /home/rapr/dictionary.xml </literal> The DICTIONARY_FILE keyword
        directs RAPR to load the <link linkend="_dictionary">dictionary</link>
        of the specified &lt;name&gt; at the specified start time. Either a
        fully qualified path or a relative path name may be specified.</para>

        <programlisting>
5.0 DICTIONARY_FILE &lt;fileName&gt;

</programlisting>
      </sect3>

      <sect3 id="_CHANGE_STATE">
        <title>CHANGE_STATE</title>

        <para><literal> Script syntax: &lt;eventTime&gt; CHANGE_STATE
        &lt;state&gt; </literal> The CHANGE_STATE keyword directs RAPR to
        change the state of the applicationto that specified. The state must
        be defined in the <link linkend="_behavior_table">behavior
        table.</link></para>

        <para>Important: To ensure that state changes occur immediately be
        sure to specify a 0.0 start time for the event. This will guarantee
        that the event will be enqueued before any other events scheduled to
        start at the same time.</para>

        <programlisting>
5.0 CHANGE_STATE 1

</programlisting>
      </sect3>

      <sect3 id="_change_ubi_state">
        <title>CHANGE_UBI_STATE</title>

        <para><literal> Script syntax: &lt;eventTime&gt; CHANGE_UBI_STATE
        &lt;ubiState&gt; </literal> The CHANGE_UBI_STATE keyword directs RAPR
        to change the UBI state of the application to that specified. The
        state must be defined in the <link linkend="_behavior_table">behavior
        table</link>. This command should only be specified in the <link
        linkend="_behavior_table">behavior table</link>. <emphasis
        role="bold">Important:</emphasis> To ensure that ubi state changes
        occur immediately be sure to specify a 0.0 start time for the event.
        This will guarantee that the event will be enqueued before any other
        events scheduled to start at the same time.</para>

        <para><para>Each behavior event is associated with a unique behavior
        identifier. In the case of interrogative objects, it is transmitted in
        the payload of outgoing messages. The <link
        linkend="_behavior_table">behavior table</link> can be configured to
        change the UBI state of history associated with any incoming messages.
        This feature is designed to handle multiple requests from an
        originating node that should not result in multiple responses. For
        example, if an originating node A sends a UDP stream to node B
        associated with a payload logic id directing node B to perform
        behavior as specified in the <link linkend="_behavior_table">behavior
        table</link>, node B's table might CHANGE_UBI_STATE so that the
        response behavior is only activated by the first response. See XXXX
        for more information on using CHANGE_UBI_STATE.
        </para><programlisting> 
0.0 CHANGE_UBI_STATE 1 1
</programlisting></para>
      </sect3>

      <sect3 id="_logicid">
        <title>LOGICID</title>

        <para><literal> Script syntax: &lt;eventTime&gt; LOGICID
        &lt;logicid&gt; </literal> The LOGICID keyword directs RAPR to invoke
        the behavior assoicated with the &lt;logicid&gt; defined in the <link
        linkend="_behavior_table">behavior table</link>. Note that the
        behavior table cannot reference packet specific translations when the
        LOGICID RAPR event is used.</para>

        <programlisting>
5.0 LOGICID 1

</programlisting>
      </sect3>

      <sect3 id="_input">
        <title>INPUT</title>

        <para><literal> Script syntax: &lt;eventTime&gt; INPUT
        &lt;fileName&gt; </literal> The INPUT keyword directs RAPR to load the
        <link linkend="_input_script">input script</link> of the specified
        &lt;name&gt; at the specified start time. Either a fully qualified
        path or a relative path name may be specified. Any events associated
        with a time will start relative to current RAPR timeline plus event
        time when the script is parsed. For example, if the current RAPR
        timeline is 5 minutes into the test, an event scheduled to start at
        5.0 in the new input script parsed will start in 5.0 seconds. Any
        events associated with times prior to the current RAPR timeline will
        start immediately.</para>

        <programlisting>
  5.0 INPUT /home/rapr/input.script

</programlisting>
      </sect3>

      <sect3 id="_raprpipe">
        <title>RAPRPIPE</title>

        <para><literal> Script syntax: RAPRPIPE &lt;pipename&gt; </literal>
        The RAPRPIPE keyword names the run-time control channel that can be
        used to control the RAPR instance. The run-time control channel is a
        unix domain datagram socket named /tmp/&lt;raprPipeName&gt; and as
        such, write access to the /tmp directory is required. Occasionally, an
        unusual abend condition might cause the socket's
        /tmp/&lt;raprPipeName&gt; file to remain after the application has
        terminated and must be deleted before subsequent pipes of the same
        name can be created.</para>

        <programlisting>
RAPRPIPE rapr-app

</programlisting>
      </sect3>

      <sect3 id="_stop">
        <title>STOP</title>

        <para><literal> Script syntax: STOP &lt;hr:min:sec&gt; </literal> The
        STOP keyword directs RAPR to stop the application at the specified
        absolute stop time.</para>

        <programlisting>
STOP 17:00:00

</programlisting>
      </sect3>

      <sect3 id="_clear">
        <title>CLEAR</title>

        <para><literal> Script syntax: [&lt;eventTime&gt;] CLEAR &lt;[ALL |
        BehaviorEventType | RAPREVENT]&gt; </literal> The CLEAR keyword
        directs RAPR to stop all objects of the specified behavior event type
        or ALL behavior events if the ALL keyword is specified at the
        specified event start time. <link linkend="_Behavior_Events">behavior
        events</link> and <link linkend="_Reception_Events">reception
        event</link> and <link linkend="_RAPR_EVENTS">RAPR events</link> can
        be cleared. All <link linkend="_RAPR_EVENTS">RAPR</link> events can be
        cleared with the RAPREVENT keyword. (Note that <link
        linkend="_GLOBAL">global commands</link> cannot be cleared.</para>

        <programlisting>
5.0 CLEAR DECLARATIVE
5.0 CLEAR ALL
5.0 CLEAR RAPREVENT
5.0 CLEAR JOIN
5.0 CLEAR CHANGE_UBI_STATE
</programlisting>
      </sect3>
    </sect2>

    <sect2 id="_GLOBAL">
      <title>Global Commands</title>

      <para>In general, a script file should contain only one occurrence of
      each global command type. If there are multiple occurrences of a command
      type, the last occurrence will determine RAPR's behavior. These commands
      can also be given on the RAPR command-line. Global commands given on the
      RAPR command-line will override any corresponding global commands in the
      script file(s). The format of script lines containing global commands
      is: &lt;command&gt; &lt;parameters&gt; The set of RAPREVENTS that are
      "Global Commands" (meaning they can be specified either in the input
      script or via the command line) includes:</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry><link linkend="hostid">HOSTID</link></entry>

              <entry>Specifies a HOSTID for the system. NOT RECOMMENDED as a
              command-line option. See <link linkend="hostid">HOSTID</link>
              for further details.</entry>
            </row>

            <row>
              <entry><link linkend="_START">START</link></entry>

              <entry>Specifies an absolute start time for script
              processing.</entry>
            </row>

            <row>
              <entry><link linkend="_OFFSET">OFFSET</link></entry>

              <entry>Specifies an offset time into script for RAPR
              activity.</entry>
            </row>

            <row>
              <entry><link linkend="_TOS">TOS</link></entry>

              <entry>Specifies a default IPv4 TOS value for IPv4
              flows.</entry>
            </row>

            <row>
              <entry><link linkend="_LABEL">LABEL</link></entry>

              <entry>Specifies a default IPv6 Flow Label for IPv6
              flows.</entry>
            </row>

            <row>
              <entry><link linkend="_TTL">TTL</link></entry>

              <entry>Specifies a default TTL (time-to-live) hop count for
              transmitted multicast packets.</entry>
            </row>

            <row>
              <entry><link linkend="_INTERFACE">INTERFACE</link></entry>

              <entry>Specifies the name of the default interface to use for IP
              multicast.</entry>
            </row>

            <row>
              <entry><link linkend="_INPUT">INPUT</link></entry>

              <entry>Specifies the name of a script file to be loaded and
              parsed.</entry>
            </row>

            <row>
              <entry><link
              linkend="_OVERWRITE_RAPRLOG">OVERWRITE_RAPRLOG</link></entry>

              <entry>Specifies the name of the log file to record logged RAPR
              events. If the named log file pre-exists, it is
              overwritten.</entry>
            </row>

            <row>
              <entry><link linkend="_RAPRLOG">RAPRLOG</link></entry>

              <entry>Same as OVERWRITE_RAPRLOG, except that pr-existing log
              files are appended instead of overwritten.</entry>
            </row>

            <row>
              <entry><link
              linkend="_OVERWRITE_MGENLOG">OVERWRITE_MGENLOG</link></entry>

              <entry>Specifies the name of the log file to record logged mgen
              events. If the named log file pre-exists, it is
              overwritten.</entry>
            </row>

            <row>
              <entry><link
              linkend="_OVERWRITE_MGENLOG">OVERWRITE_MGENLOG</link></entry>

              <entry>Same as OVERWRITE_MGENLOG, except that pr-existing log
              files are appended instead of overwritten.</entry>
            </row>

            <row>
              <entry><link linkend="_TXBUFFER">TXBUFFER</link></entry>

              <entry>Specifies a default socket transmit buffer size.</entry>
            </row>

            <row>
              <entry><link linkend="_RXBUFFER">RXBUFFER</link></entry>

              <entry>Specifies a default socket receive buffer size.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <sect3 id="_hostid">
        <title id="hostid">HOSTID</title>

        <para><literal>Script syntax: HOSTID &lt;hostId&gt; </literal> This
        command specifies the HOSTID to be used by RAPR. HOSTID is used by the
        RAPR application to identify it's own network traffic and as such must
        be unique within a set of interoperating RAPR applications. If no
        HOSTID is specified the last octet of the host's IP address will be
        used. For example, given an IP address of 192.168.1.101, "101" will be
        used as the HOSTID.</para>

        <para>Currently the maximum hostid allowed is 255.</para>

        <para>Although available as a command-line option, it is not
        recommended to be used this way as it will be overwritten by any
        subsequent HOSTID definitions in the input script (if
        specified).</para>

        <para>HOSTID will also be used to seed the system-wide random number
        generator if no <link linkend="initial_seed">INITIAL_SEED</link> is
        set and should always be the first entry in the input script such that
        any subsequent seed assignments are consistent. If an <link
        linkend="???">INITIAL_SEED</link> is specified however, it will be
        used as the seed.</para>

        <para><emphasis>NOTE: HOSTID must be specified as the first entry (or
        second entry, if an INITIAL_SEED is also specified) in an input script
        as subsequent commands may require that random number draws be made.
        See the <link linkend="repeatability">repeatability section</link> for
        more information on seeding.</emphasis></para>
      </sect3>

      <sect3 id="_hostid">
        <title id="initial_seed">INITIAL_SEED</title>

        <para><literal> Script syntax: INITIAL_SEED &lt;seedValue&gt;
        </literal> This command specifies the initial seed value to be used by
        RAPR to seed its random number generator. It is not recommended to be
        used as a command line option. RAPR will use the host id if specified
        or the DEFAULT host id as indicated by the node's local ip address as
        the initial_seed value if no INITIAL_SEED command is specified. E.g.
        If no host id or initial seed is specified, given an ip address of
        192.168.1.103, "103" will be used as the default INITIAL_SEED
        value.</para>

        <para><emphasis>NOTE: INITIAL_SEED must be specified as the first
        entry in an input script as subsequent commands may require that
        random number draws be made. See the repeatability section for more
        information on seeding.</emphasis></para>
      </sect3>

      <sect3 id="_START">
        <title>START</title>

        <para><literal> Script syntax: START &lt;hour:min:sec&gt;[GMT]
        </literal> The START command designates an absolute time as indicated
        by the &lt;hour:min:sec&gt; field to correspond to the relative script
        time of 0.0 seconds. All transmission and reception events will be
        scheduled relative to this absolute start time. The optional GMT
        suffix (no white space after the time) indicates that the clock time
        given is Greenwich Mean Time (GMT) rather than the operating systems
        local time zone. If no START command is given, RAPR schedules
        transmission and reception events relative to program startup.
        Example:</para>

        <programlisting>
#Start RAPR exactly at 1:30PM local time
START 13:30:00

#Start RAPR at 30 seconds past 8:30 
GMTSTART 8:30:30GMT

</programlisting>
      </sect3>

      <sect3 id="_OFFSET">
        <title>OFFSET</title>

        <para><literal> Script syntax: OFFSET &lt;seconds&gt; </literal> The
        OFFSET global command specifies a relative time offset (in
        seconds)into script processing where RAPR should begin its activity.
        This allows multiple instances of RAPR using the same script to be
        dithered as desired. Additionally, this command may be used to
        immediately restore RAPR to a specific scripted state other than the
        beginning of the script upon launch. Example:</para>

        <programlisting>
#Skip the first 10 seconds of an RAPR script
OFFSET 10.0
</programlisting>
      </sect3>

      <sect3 id="_TOS">
        <title>TOS</title>

        <para><literal> Script syntax: TOS &lt;value&gt; </literal> The TOS
        command specifies the type of service to be applied to the
        messages.</para>

        <programlisting>
Example:
#Specify default ttl = 0x10 (low delay)
TOS 0x10
</programlisting>
      </sect3>

      <sect3 id="_LABEL">
        <title>LABEL</title>

        <para><literal> Script syntax: LABEL &lt;value&gt; </literal> The
        LABEL command specifies a default value to be used as the "flow label"
        for IPv6 flows. The "flow label" is the corresponding 28-bit field in
        the IPv6 packet header. Refer to the Transmission Event <link
        linkend="_IPv6_Flow_Label">LABEL</link> option for further details..
        Example:</para>

        <programlisting>
#Specify default IPv6 flow label = 0x02500000
LABEL 0x02500000
</programlisting>
      </sect3>

      <sect3 id="_TTL">
        <title>TTL</title>

        <para><literal> Script syntax: TTL &lt;value&gt; </literal> The TTL
        command specifies the default time-to-live (TTL) hop count for
        generated IP multicast traffic according to the &lt;value&gt; field.
        The &lt;value&gt; must be in the range of 1-255. If the global TTL
        command is not used, RAPR assumes a default multicast TTL value of 3.
        Note that the transmission event TTL option will override the default
        specification given by this global command. Example:</para>

        <programlisting>
#Specify default multicast flow ttl = 32
TTL 32
</programlisting>
      </sect3>

      <sect3 id="TXBUFFER">
        <title>TXBUFFER</title>

        <para><literal> Script syntax: TXBUFFER &lt;txBufferSize&gt; ...
        </literal> This option allows users to set the default socket transmit
        buffer size to a value Òat leastÓ as large as &lt;txBufferSize&gt;.
        The exact behavior of this option may be operating system dependent.
        The TXBUFFER option given on transmission event script lines will
        override this default for the socket used by the corresponding
        flow.</para>
      </sect3>

      <sect3 id="RXBUFFER">
        <title>RXBUFFER</title>

        <para><literal> Script syntax: RXBUFFER &lt;rxBufferSize&gt; ...
        </literal> This option allows users to set the default socket receive
        buffer size to a value Òat leastÓ as large as &lt;rxBufferSize&gt;.
        The exact behavior of this option may be operating system dependent.
        The RXBUFFER option given on transmission event script lines will
        override this default for the socket used by the corresponding
        flow.</para>
      </sect3>

      <sect3 id="_INTERFACE">
        <title>INTERFACE</title>

        <para><literal> Script syntax: INTERFACE &lt;interfaceName&gt;
        </literal> The INTERFACE command specifies a default IP network
        interface to use for multicast traffic generation and group
        membership. If no INTERFACE command is given, the default operating
        system behavior is observed. Note that the transmission event
        INTERFACE option or the JOIN reception event INTERFACE option will
        override the default specification given by this global command.
        Example:</para>

        <programlisting>
#Specify "eth1" as the default network interface 
#for multicast transmission and group joins
INTERFACE eth1
</programlisting>
      </sect3>

      <sect3 id="_INPUT">
        <title>INPUT</title>

        <para><literal> Script syntax: INPUT &lt;scriptFile&gt; </literal> The
        INPUT command cause RAPR to load and parse the given
        &lt;scriptFile&gt;. (Circular references are not detected by RAPR and
        should be avoided_). This allows scripts to "include" other scripts.
        The parsing occurs in the order that the INPUT commands are
        encountered on the command-line and within the script files
        themselves. Any events associated with a time will start relative to
        current RAPR timeline plus event time when the script is parsed. For
        example, if the current RAPR timeline is 5 minutes into the test, an
        event scheduled to start at 5.0 in the new input script parsed will
        start in 5.0 seconds. Any events associated with times prior to the
        current RAPR timeline will start immediately. Example:</para>

        <programlisting>
#Load and parse the RAPR script file "script2.mgn"
INPUT script2.mgn
</programlisting>
      </sect3>

      <sect3 id="_OVERWRITE_RAPRLOG">
        <title>OVERWRITE_RAPRLOG</title>

        <para><literal> Script syntax: OVERWRITE_RAPRLOG &lt;logFile&gt;
        </literal> The OVERWRITE_RAPRLOG command cause RAPR to direct its RAPR
        log output to the indicated &lt;logFile&gt;. The last occurring
        OVERWRITE_RAPRLOG command determines the log file to be used and the
        command-line takes precedence over any scripts provided as input to
        RAPR. The file named by &lt;logFile&gt; will be overwritten if it
        already exists. Example:</para>

        <programlisting>
#Use the file "logFile.log" for logging
OVERWRITE_RAPRLOG logFile.log
</programlisting>
      </sect3>

      <sect3 id="_OVERWRITE_MGENLOG">
        <title>OVERWRITE_MGENLOG</title>

        <para><literal> Script syntax: OVERWRITE_MGENLOG &lt;logFile&gt;
        </literal> The OVERWRITE_MGENLOG command cause RAPR to direct its mgen
        log output to the indicated &lt;logFile&gt;. The last occurring
        OVERWRITE_MGENLOG command determines the log file to be used and the
        command-line takes precedence over any scripts provided as input to
        RAPR. The file named by &lt;logFile&gt; will be overwritten if it
        already exists. Example:</para>

        <programlisting>
#Use the file "logFile.log" for logging
OVERWRITE_MGENLOG logFile.log
</programlisting>
      </sect3>

      <sect3 id="_RAPRLOG">
        <title>RAPRLOG</title>

        <para><literal> Script syntax: RAPRLOG &lt;logFile&gt; </literal> The
        RAPRLOG command cause RAPR to direct its RAPR log output to the
        indicated &lt;logFile&gt;. The last occurring RAPRLOG command
        determines the log file to be used and the command-line takes
        precedence over any scripts provided as input to RAPR. The file named
        by &lt;logFile&gt; will be appended if it already exists.
        Example:</para>

        <programlisting>
#Append the file "logFile.log" 
RAPRLOG logFile.log
</programlisting>
      </sect3>

      <sect3 id="MGENLOG">
        <title>MGENLOG</title>

        <para><literal> Script syntax: MGENLOG &lt;logFile&gt; </literal> The
        MGENLOG command cause RAPR to direct its mgen log output to the
        indicated &lt;logFile&gt;. The last occurring MGENLOG command
        determines the log file to be used and the command-line takes
        precedence over any scripts provided as input to RAPR. The file named
        by &lt;logFile&gt; will be appended if it already exists.
        Example:</para>

        <programlisting>
#Append the file "logFile.log" 
MGENLOG logFile.log
</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="_RAPR_Log_File">
    <title>RAPR Log File Format</title>

    <para>The RAPR log file records details about application behavior and
    events, for example when a behavior event starts or stops or the time the
    application started.</para>

    <sect2 id="General_RAPR_Log_Format">
      <title>General RAPR Log Format</title>

      <para>Each line of the RAPR text log file corresponds to a unique
      application event and follows the convention: &lt;eventTime&gt;
      app&gt;&lt;appType&gt; type&gt;&lt;eventType&gt;
      action&gt;&lt;actionType&gt; &lt;event attributes ...&gt; The
      &lt;eventTime&gt; field is in the form hrs:min:sec and represents the
      computer's system time at the time of the event. The &lt;appType&gt;
      type will always be RAPR. This field is used to differentiate RAPR
      events from MGEN events when both events are written to the same output
      stream. The &lt;eventType&gt; field reflects the application event and
      is one of the following:</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>Application</entry>

              <entry>Denotes an application specific event.</entry>
            </row>

            <row>
              <entry><link linkend="_Rapr_Events">RaprEvent</link></entry>

              <entry>Indicates a RAPR Event was processed, e.g. loading a
              logictable, changing application state .</entry>
            </row>

            <row>
              <entry>Error</entry>

              <entry>Denotes a RAPR error, for example error loading a
              file.</entry>
            </row>

            <row>
              <entry><link linkend="_declarative">Declarative</link></entry>

              <entry>Indicates a declarative event has occurred.</entry>
            </row>

            <row>
              <entry><link
              linkend="_interrogative">Interrogative</link></entry>

              <entry>Indicates an interrogative event has occurred.</entry>
            </row>

            <row>
              <entry><link linkend="_stream">Stream</link></entry>

              <entry>Indicates a stream event has occurred.</entry>
            </row>

            <row>
              <entry><link linkend="_periodic">Periodic</link></entry>

              <entry>Indicates that a periodic event has occurred.</entry>
            </row>

            <row>
              <entry><link
              linkend="_Reception_Events">ReceptionEvent</link></entry>

              <entry>Indicates a reception event has occurred.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The &lt;eventAttritbutes&gt; vary depending on the event type.
      Sample log file entries:</para>

      <programlisting>
<literal>
20:08:04.534996 app&gt;RAPR type&gt;Application action&gt;ApplicationStartUp
20:08:04.538719 app&gt;RAPR type&gt;RaprEvent action&gt;loading_logictable \
name&gt;../docs/client_logictable.xml
20:08:04.549056 app&gt;RAPR type&gt;Reception action&gt;start ubi&gt;1023410177 \
eventSource&gt;script_event endTime&gt;3600.00 mgenCmd&gt;"LISTEN TCP 5000,"
20:08:04.562810 app&gt;RAPR type&gt;Declarative action&gt;start ubi&gt;1023410178 \
eventSource&gt;script_event payload&gt;1 endTime&gt;0.01 seed&gt;261992998 
payloadSeed&gt;932359081 mgenCmd&gt;"ON 1 TCP SRC 0 DST 192.168.1.102/5000 
PERIODIC [1 409 ] DATA [0204010000000304A9AB9237]"
20:08:04.601751 app&gt;RAPR type&gt;Declarative action&gt;start ubi&gt;1023410180 \
eventSource&gt;net_event payload&gt;2 endTime&gt;0.01 seed&gt;2073794103 \
payloadSeed&gt;1724104380 mgenCmd&gt;"ON 2 TCP SRC 0 DST 192.168.1.102/5000 \
PERIODIC [1 636 ] DATA [0204020000000304BCBEC366]"
20:08:04.616256 app&gt;RAPR type&gt;Declarative action&gt;timeout ubi&gt;1023410178 \
0.001 OFF 1
20:08:04.621802 app&gt;RAPR type&gt;Declarative action&gt;timeout ubi&gt;1023410180 \
0.001 OFF 2
20:08:06.616553 app&gt;RAPR type&gt;Declarative action&gt;start ubi&gt;1023410181 \
eventSource&gt;net_event payload&gt;2 startTime&gt;2.00 endTime&gt;0.01 seed&gt;1913224746 \
payloadSeed&gt;925395647 mgenCmd&gt;"ON 1 TCP SRC 0 DST 192.168.1.102/5000 \
PERIODIC [1 637 ] DATA [0204020000000304BF6A2837]"
20:08:06.616673 app&gt;RAPR type&gt;Declarative action&gt;timeout ubi&gt;1023410181 
0.001 OFF 1
</literal>
</programlisting>

      <para>The DATA field may contain some RAPR specific directives like the
      triggering behavior event's UBI for interrogative objects, random seed,
      any payload logic ID, etc. RAPR specific payload content will be
      displayed in hex values in the log files as:</para>

      <programlisting>

Example RAPR payload with two fields:
DATA [0204020000000304BF6A2837]

First field: 020402000000
02: Rapr Field type indicator
04: Rapr Field length
02000000: Rapr Field Value

Second Field: 0304BF6A2837
03: Rapr Field type indicator
04: Rapr Field length
BF6A2837: Rapr Field Value
</programlisting>

      <para>The hex field indicators can be translated as follows:</para>

      <itemizedlist>
        <listitem>
           01 RAPR UBI 
        </listitem>

        <listitem>
           02 RAPR Payload Logic ID 
        </listitem>

        <listitem>
           03 RAPR Seed 
        </listitem>

        <listitem>
           04 RAPR Foreign UBI 
        </listitem>

        <listitem>
           05 RAPR StreamID 
        </listitem>

        <listitem>
           06 RAPR Stream Sequence Number 
        </listitem>

        <listitem>
           07 RAPR Stream Duration 
        </listitem>

        <listitem>
           08 RAPR Stream Burst Count 
        </listitem>

        <listitem>
           09 RAPR Stream Burst Payload ID 
        </listitem>

        <listitem>
           0A RAPR Stream Burst Priority 
        </listitem>
      </itemizedlist>

      <para>In general, all RAPR messages will contain at least a seed
      value.</para>
    </sect2>
  </sect1>

  <sect1 id="_MGEN_Log_File">
    <title>MGEN Log File Format</title>

    <para><anchor id="b5"/><anchor id="b7"/>The MGEN message format contains
    information to facilitate network performance measurements through
    post-analysis of MGEN log files. Some of the types of performance
    statistics which can be determined include:</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>Message Throughput</entry>

            <entry>The time or arrival and size of received messages are
            logged by MGEN receivers. Network throughput can be assessed with
            this information.</entry>
          </row>

          <row>
            <entry>Message Delivery Latency</entry>

            <entry>MGEN messages contain a timestamp reflecting when they were
            sent and the time of reception is logged by MGEN receivers.
            Delivery latency statistics (jitter or absolute if clock
            synchronization (e.g. NTP) is possible) can be determined with
            this information.</entry>
          </row>

          <row>
            <entry>Message Loss Rate</entry>

            <entry>MGEN messages are sequence numbered. Message loss can be
            accounted for via analysis of logged sequence number
            information.</entry>
          </row>

          <row>
            <entry>Message Re-ordering</entry>

            <entry>The logged MGEN sequence number information can also be
            used to determine message re-ordering statistics.</entry>
          </row>

          <row>
            <entry>Multicast JOIN/LEAVE Latency</entry>

            <entry>The occurrence and time of JOIN/LEAVE events are logged by
            MGEN receivers. The JOIN latency can be determined by comparing
            the arrival time of the first message associated with a particular
            multicast group to the time the group was joined. The LEAVE
            latency can be determined by comparing the time of the _last_
            packet arrival time to the time the receiver left that multicast
            group (Note that you need a packet sniffing program like <ulink
            url="http://www.tcpdump.org/">tcpdump</ulink> to see packets after
            you leave the group).</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Many of the above performance measures and statistics can be
    measured and optionally graphed using the NRL <ulink
    url="http://www.nrl.navy.mil/itd/ncs/products/protean_tools">trpr</ulink>
    (trace plot real-time) program. This program can parse the MGEN log file
    format and <ulink url="http://www.tcpdump.org/">tcpdump</ulink>
    traces.</para>

    <sect2 id="General_Log_Format">
      <title>General Log Format</title>

      <para>Each line of the MGEN text log file format corresponds to a unique
      event and follows the convention:&lt;eventTime&gt; &lt;eventType&gt;
      &lt;event attributes ...&gt;The &lt;eventTime&gt; field is in the form
      hrs:min:sec and represents the computer's system Greenwich Mean Time
      (GMT) at the time of the event.</para>

      <para>The &lt;eventType&gt; field is one of the following:</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry><link linkend="_Log_File_RECV">RECV</link></entry>

              <entry>Denotes the arrival of a received MGEN message.</entry>
            </row>

            <row>
              <entry><link linkend="_Log_File_RERR">RERR</link></entry>

              <entry>Indicates an invalid MGEN message was received.</entry>
            </row>

            <row>
              <entry><link linkend="_Log_File_SEND_Events">SEND</link></entry>

              <entry>Denotes the transmission of an MGEN message.</entry>
            </row>

            <row>
              <entry><link linkend="_Log_File_JOIN">JOIN</link></entry>

              <entry>Marks a join to an IP multicast group.</entry>
            </row>

            <row>
              <entry><link linkend="_Log_File_LEAVE">LEAVE</link></entry>

              <entry>Marks the departure from an IP multicast group.</entry>
            </row>

            <row>
              <entry><link linkend="_Log_File_LISTEN">LISTEN</link></entry>

              <entry>Indicates when mgen began monitoring a specific
              port</entry>
            </row>

            <row>
              <entry><link linkend="_Log_File_IGNORE">IGNORE</link></entry>

              <entry>Indicates when mgen ended monitoring of a specific
              port</entry>
            </row>

            <row>
              <entry><link linkend="_Log_File_ON">ON</link></entry>

              <entry>Indicates when mgen initiated a TCP connection to the
              indicated destination ip address and port.</entry>
            </row>

            <row>
              <entry><link linkend="_Log_File_CONNECT">CONNECT</link></entry>

              <entry>Indicates when mgen established a TCP connection from the
              indicated source ip address and port or to the indicated
              destination ip address and port.</entry>
            </row>

            <row>
              <entry><link
              linkend="_Log_File_DISCONNECTED">DISCONNECTED</link></entry>

              <entry>Indicates when an mgen TCP connection was disconnected
              prior to a scheduled &gt;OFF&lt; event on either the client or
              server side. This event indicates a TCP error has occurred on
              the connection.</entry>
            </row>

            <row>
              <entry><link linkend="_Log_File_OFF">OFF</link></entry>

              <entry>Indicates that an mgen flow was stopped by a scheduled
              &gt;OFF&lt; event (only available when transmission logging is
              enabled on the client side)and is logged by both the TCP client
              and server.</entry>
            </row>

            <row>
              <entry><link linkend="_Log_File_Start_Stop">START</link></entry>

              <entry>Indicates when mgen started processing Transmission and
              Reception events.</entry>
            </row>

            <row>
              <entry><link linkend="_Log_File_Start_Stop">STOP</link></entry>

              <entry>Indicates when mgen stopped processing Transmission and
              Reception events.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Different event types will have different event attribute sets.
      The &lt;event attribute&gt; fields are explicitly labeled so that log
      file parsing programs can seek specific attributes of interest for given
      event types.</para>
    </sect2>

    <sect2 id="_Log_File_RECV">
      <title>Log File RECV Events</title>

      <para>The format of the RECV event log file line is:</para>

      <para><literal>&lt;eventTime&gt; RECV proto&gt;&lt;protocol&gt;
      flow&gt;&lt;flowId&gt; seq&gt;&lt;sequenceNumber&gt; src&gt;&lt;addr&gt;
      /&lt;port&gt; dst&gt;&lt;addr&gt;/&lt;port&gt; sent&gt;&lt;txTime&gt;
      size&gt;&lt;bytes&gt; [host&gt;&lt;addr&gt;/&lt;port&gt;]
      [gps&gt;&lt;status&gt;,&lt;lat&gt;,&lt;long&gt;,&lt;alt&gt;]
      [data&gt;&lt;len&gt;:&lt;data&gt;]
      [flags&gt;&lt;flag&gt;]</literal></para>

      <para>The &lt;eventTime&gt; corresponds to when the message was
      received. The &lt;protocol&gt; specifies the protocol (udp,tcp,sink).The
      &lt;flowId&gt;, &lt;sequenceNumber&gt;, and &lt;txTime&gt;, are from the
      payload of the MGEN message. The &lt;txTime&gt; is in the same format as
      the &lt;eventTime&gt; (i.e. &lt;hr:min:sec&gt; GMT)</para>

      <para>The "dst" &lt;addr&gt;/&lt;port&gt; is from the message payload
      and corresponds to the destination address to which the source addressed
      the MGEN message.</para>

      <para>The "src" &lt;addr&gt;/&lt;port&gt; is the source address
      determined from the corresponding <literal>recvfrom()</literal> call for
      UDP transport or the address to which the TCP connection was made. (An
      optional "host" address will be embedded in the payload by the MGEN
      message source and made available as an attribute of the logged RECV
      event in the future).</para>

      <para>The message "size" in &lt;bytes&gt; is also from the payload, but
      for UDP transport, should also correspond to the UDP packet payload
      size. Note that TCP mgen messages can be larger than the maximum UDP
      message size of 8192 bytes and can be of unlimited size. Therefore, mgen
      breaks large TCP messages into mgen message "fragments" of a maximum
      size of 65535 and sets a flag on the mgen message to indicate that it is
      a TCP message "fragment". Message fragments are flagged with 0x01 to
      indicate that the message is not complete. The last fragment in a TCP
      message is flagged 0x02 to indicate "end of message".</para>

      <para>For example, a TCP mgen message of size 66559 will be received and
      logged by the receiving node as two messages as follows:</para>

      <para>00:33:36.427143 RECV proto&gt;TCP flow&gt;1 seq&gt;1
      src&gt;192.168.1.102/35056 dst&gt;192.168.1.100/5000
      sent&gt;00:36:11.377105 size&gt;65535
      gps&gt;INVALID,999.000000,999.000000,-999 flags&gt;0x01</para>

      <para>00:33:36.427499 RECV proto&gt;TCP flow&gt;1 seq&gt;1
      src&gt;192.168.1.102/35056 dst&gt;192.168.1.100/5000
      sent&gt;00:36:11.380137 size&gt;1024
      gps&gt;INVALID,999.000000,999.000000,-999 flags&gt;0x02</para>

      <para>Also note that a single SEND message will be logged by the
      transmitting node with a size corresponding to the TCP message size,
      e.g.:</para>

      <para>00:29:51.396962 SEND proto&gt;TCP flow&gt;1 seq&gt;1 srcPort&gt;0
      dst&gt;192.168.1.102/5000 size&gt;66559</para>

      <para>The "host" &lt;addr&gt;/&lt;port&gt; corresponds to the MGEN
      message source's "perceived" default local address. Note that this may
      be different from the source address contained in the MGEN log file due
      to firewalls, Network Address Translation (NAT) devices, multi-homed
      sources, etc. The accuracy of this information depends upon the source
      host's configuration with regards to domain name service (DNS), etc.
      Note this field is optional and may not be present if this information
      is not valid (The current initial MGEN release does not yet support this
      option).</para>

      <para>The "src", "dst", and "host" &lt;addr&gt; fields are dotted
      decimal IPv4 addresses or colon-delimited IPv6 addresses.</para>

      <para>The "flags" field is discussed above.</para>

      <para>The global positioning system (GPS) information is available when
      the MGEN message source is used in conjunction with the NRL <ulink
      url="http://www.nrl.navy.mil/itd/ncs/products/protean_tools">gpsLogger</ulink>
      program. This program monitors an attached GPS receiver for position
      information and "publishes" it in shared memory. When mgen is run and
      detects that it can "subscribe" to GPS position information, it places
      it in the MGEN message payload. Note that <ulink
      url="http://www.nrl.navy.mil/itd/ncs/products/protean_tools">gpsLogger</ulink>
      can also be used with a pulse-per-second (PPS) capable GPS receiver to
      provide accurate time synchronization for hosts running the MGEN
      toolset. This may be useful for mobile network test environments. The
      MGEN log file "gps" attribute has the following comma-delimited
      fields:</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>&lt;status&gt;</entry>

              <entry>This indicates the validity of the GPS information and
              may be either "INVALID", "CURRENT", or "STALE".</entry>
            </row>

            <row>
              <entry>&lt;lat&gt;</entry>

              <entry>This is the GPS latitude in degrees. A negative value
              denotes South while a positive value denotes North.</entry>
            </row>

            <row>
              <entry>&lt;long&gt;</entry>

              <entry>This is the GPS longitude in degrees. A negative value
              denotes West while a positive value denotes East.</entry>
            </row>

            <row>
              <entry>&lt;alt&gt;</entry>

              <entry>This is the GPS altitude in meters.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The optional "data" attribute is present only if the received MGEN
      message contains optional user-defined payload. If present, the
      &lt;len&gt; indicates the length (in bytes) of the user-defined payload
      and the &lt;data&gt; following the colon character':' is a hexadecimal
      representation of the user data where each pair of characters
      corresponds to one byte of user data. Thus, the number of characters in
      the &lt;data&gt; field will be 2 * &lt;len&gt;. (The "data" option was
      supported in MGEN 3.x via the MGEN Payload Manager (mpmgr) tool and is
      not yet supported in MGEN 4.x. The documentation will be updated when
      this option is supported).</para>

      <para>Example RECV event log lines:<literal/></para>

      <para><literal>22:59:52.312721 RECV proto&gt;&lt;protocol&gt; flow&gt;1
      seq&gt;1 src&gt;132.250.68.21/5000 dst&gt;132.259.43.96/5002
      sent&gt;22:59:52.310324 size&gt;1024</literal></para>

      <para><literal>23:59:53.312721 RECV proto&gt;&lt;protocol&gt; flow&gt;1
      seq&gt;2 src&gt;132.250.68.21/5000 dst&gt;132.259.43.96/5002
      sent&gt;22:59:52.310324 size&gt;1024 host&gt;132.250.68.21/5000
      gps&gt;CURRENT,35.123,79.234,57</literal></para>

      <para><literal>23:59:53.312721 RECV proto&gt;&lt;protocol&gt; flow&gt;1
      seq&gt;2 src&gt;132.250.68.21/5000 dst&gt;132.259.43.96/5002
      sent&gt;22:59:52.310324 size&gt;1024 host&gt;132.250.68.21/5000
      gps&gt;CURRENT,35.123,79.234,57
      data&gt;10:01a97b34458cff0021e8</literal></para>
    </sect2>

    <sect2 id="_Log_File_RERR">
      <title>Log File RERR Events</title>

      <para>The format of the RERR (Receive Error) event log file line
      is:<literal/></para>

      <para><literal>&lt;eventTime&gt; RERR proto&gt;&lt;protocol&gt;
      type&gt;&lt;errorType&gt;
      src&gt;&lt;addr&gt;/&lt;port&gt;</literal></para>

      <para>The &lt;eventTime&gt; corresponds to when the message in error was
      received. The &lt;errorType&gt; is one of "none", "version", "checksum",
      or "dstaddr". An receive error of type "version" indicates the MGEN
      sender is using an mgen executable with an incompatible version number.
      The "checksum" error indicates the received message failed checksum
      validation, and the "dstaddr" error indicates an invalid or unsupported
      destination address type in the MGEN message received. The &lt;src&gt;
      attribute indicates the source address of the message in error.</para>
    </sect2>

    <sect2 id="_Log_File_SEND_Events">
      <title>Log File SEND Events</title>

      <para>The format of the SEND event log file line is:<literal/></para>

      <para><literal>&lt;eventTime&gt; SEND proto&gt;&lt;protocol&gt;
      flow&gt;&lt;flowId&gt; seq&gt;&lt;sequenceNumber&gt;
      src&gt;&lt;srcPort&gt; dst&gt;&lt;addr&gt;/&lt;port&gt;
      size&gt;&lt;bytes&gt;
      [host&gt;&lt;addr&gt;/&lt;port&gt;]</literal></para>

      <para>The &lt;eventTime&gt; corresponds to when the message was sent,
      and it should precisely match the &lt;txTime&gt; logged by the machine
      the packet is sent to, if the packet is received correctly.</para>

      <para>All the data items are the same as those used in the Log File RECV
      Events.</para>
    </sect2>

    <sect2 id="_Log_File_JOIN">
      <title>Log File JOIN Events</title>

      <para>The format of the JOIN log file event line is:</para>

      <para>&lt;eventTime&gt; JOIN group&gt; &lt;groupAddress&gt;
      [interface&gt; &lt;interfaceName&gt;]</para>

      <para>The &lt;groupAddress&gt; is the IP multicast group address which
      was joined. The format of this field is either a dotted decimal IPv4
      address or a colon-delimited IPv6 address. The &lt;interfaceName&gt; is
      given only when the executed MGEN script used the INTERFACE option in
      the corresponding <link linkend="_JOIN">JOIN</link> script event.</para>

      <para>Example JOIN event log lines:</para>

      <para><literal>22:59:50:234757 JOIN group&gt;224.1.2.3</literal></para>

      <para><literal>22:59:51:129574 JOIN group&gt;224.1.2.4
      interface&gt;eth1</literal></para>
    </sect2>

    <sect2 id="_Log_File_LEAVE">
      <title>Log File LEAVE Events</title>

      <para>The format of log file LEAVE event lines is:</para>

      <para>&lt;eventTime&gt; LEAVE group&gt;&lt;groupAddress&gt;
      [interface&gt;&lt;interfaceName&gt;]</para>

      <para>The &lt;groupAddress&gt; is the IP multicast group address which
      was left. The format of this field is either a dotted decimal IPv4
      address or a colon-delimited IPv6 address. The &lt;interfaceName&gt; is
      given only when the executed MGEN script used the INTERFACE option in
      the corresponding <link linkend="_LEAVE">LEAVE</link> script
      event.</para>

      <para>Example LEAVE event log lines:<literal/></para>

      <para><literal>22:59:59:234757 LEAVE group&gt;224.1.2.3</literal></para>

      <para><literal>22:59:59:753683 LEAVE group&gt;224.1.2.4
      interface&gt;eth1</literal></para>
    </sect2>

    <sect2 id="_Log_File_LISTEN">
      <title>Log File LISTEN Events</title>

      <para>The format of the LISTEN event log file line is:<literal/></para>

      <para><literal>&lt;eventTime&gt; LISTEN proto&gt;&lt;protocol&gt;
      port&gt;&lt;portNumber&gt;</literal></para>

      <para>The &lt;protocol&gt; field corresponds to the transport protocol
      type being used. Supported protocols include "UDP" and "TCP". The
      &lt;portNumber&gt; field is the host port number to be monitored.</para>

      <para>Example LISTEN event log lines:<literal/></para>

      <para><literal>22:59:48:834205 LISTEN proto&gt;UDP
      port&gt;5000</literal></para>

      <para><literal>22:59:49:328039 LISTEN proto&gt;UDP
      port&gt;5001</literal></para>
    </sect2>

    <sect2 id="_Log_File_IGNORE">
      <title>Log File IGNORE Events</title>

      <para>The format of the IGNORE event log file line is:</para>

      <para><literal>&lt;eventTime&gt; IGNORE proto&gt;&lt;protocol&gt;
      port&gt;&lt;portNumber&gt;</literal></para>

      <para>The &lt;protocol&gt; field corresponds to the transport protocol
      type which was being used. Supported protocols include "UDP" and "TCP".
      The &lt;portNumber&gt; field is the host port number to be no longer
      monitored.</para>

      <para>Example IGNORE event log lines:<literal/></para>

      <para><literal>23:00:00:723467 IGNORE proto&gt;UDP
      port&gt;5000</literal></para>

      <para><literal>23:01:00:235629 IGNORE proto&gt;UDP
      port&gt;5001</literal></para>
    </sect2>

    <sect2 id="_Log_File_ON">
      <title>Log File ON Events</title>

      <para>The format of the ON event log file line is:<literal/></para>

      <para><literal>&lt;eventTime&gt; ON flow&gt;&lt;flowID&gt;
      dst&gt;&lt;dst&gt;/&lt;portNumber&gt;</literal></para>

      <para>This event indicates that mgen has attempted to establish a TCP
      connection with the target destination address and port. It does not
      indicate that the connection has been successfully established, only
      that a connection has been attempted. The &lt;flowID&gt; field
      corresponds to the TCP flow ID of the connection. The &lt;dst&gt; field
      corresponds to the destination of the TCP connection. The
      &lt;portNumber&gt; field is the destination port number of the TCP
      connection.</para>

      <para>Example ON event log lines:</para>

      <para><literal>23:00:00:723467 ON flow&gt;1
      dst&gt;192.168.1.100/5000</literal></para>
    </sect2>

    <sect2 id="_Log_File_CONNECT">
      <title>Log File CONNECT Events</title>

      <para>The format of the CONNECT event log file line is:</para>

      <para>&lt;eventTime&gt; CONNECT
      src&gt;&lt;src&gt;/&lt;portNumber&gt;</para>

      <para>&lt;eventTime&gt; CONNECT flow&gt;&lt;flowId&gt;
      dst&gt;&lt;dst&gt;/&lt;portNumber&gt;</para>

      <para>The &lt;src&gt; and &lt;dst&gt; fields correspond to the source or
      destination ip address of the TCP connection. The &lt;src&gt; and
      &lt;dst&gt; &lt;portNumber&gt; field is the source or destination port
      number of the TCP connection. The &lt;flowID&gt; is only available for
      client-side (originator) events.</para>

      <para>Example CONNECT event log line (server):</para>

      <para>23:00:00:723467 CONNECT src&gt;192.168.1.100/34730</para>

      <para>Example CONNECT event log line (client):<literal/></para>

      <para><literal>23:00:00:723467 CONNECT flow&gt;1
      dst&gt;192.168.1.102/5000</literal></para>
    </sect2>

    <sect2 id="_Log_File_DISCONNECTED">
      <title>Log File DISCONNECTED Events</title>

      <para>The format of the DISCONNECTED event log file line is:</para>

      <para>&lt;eventTime&gt; DISCONNECTED flow&gt;&lt;flowID&gt;
      src&gt;&lt;src&gt;/&lt;portNumber&gt; status&gt;&lt;status&gt;</para>

      <para>This event indicates that a TCP connection with the indicated
      address and port has disconnected either because the connection could
      not be established in the first place or because the connection was
      prematurely terminated. In the TCP client's log file, the dst address
      and port reflect the address and port of the node the client was
      attempting to connect to. In the TCP server's log file, the src address
      and port reflects the address and port of the connecting node. The
      &lt;flowID&gt; field corresponds to the TCP flow ID of the connection
      (this field is only available in the client's event log). Note that if a
      TCP connection was not prematurely terminated, no DISCONNECTED event
      will be logged.</para>

      <para>Example Client DISCONNECTED event log line
      (client):<literal/></para>

      <para><literal>23:00:00:723467 DISCONNECTED flow&gt;1
      dst&gt;192.168.1.102/5000</literal></para>

      <para>Example Server DISCONNECTED event log line
      (server):<literal/></para>

      <para><literal>23:00:00:723467 DISCONNECTED
      src&gt;192.168.1.100/32423</literal></para>
    </sect2>

    <sect2 id="_Log_File_OFF">
      <title>Log File OFF Events</title>

      <para>The format of the OFF event log file line is:</para>

      <para>&lt;eventTime&gt; OFF [flow&gt; &lt;flowID&gt;]
      [src&gt;&lt;src&gt;|dst&gt;&lt;dst&gt;]/&lt;portNumber&gt;</para>

      <para>This event indicates that a TCP connection with the indicated
      address and port has been disconnected as scheduled as planned by an
      mgen OFF event or because the flow sent the required <link
      linkend="_COUNT">COUNT</link> of packets. In the TCP client's log file,
      the dst address and port reflect the address and port of the node the
      client was connected to. In the TCP server's log file, the src address
      and port reflects the address and port of the connecting node. The
      &lt;flowID&gt; field corresponds to the TCP flow ID of the connection
      (this field is only available in the client's event log). Note that if a
      TCP connection was prematurely terminated by either the client or the
      server, no OFF event will be logged.</para>

      <para>Example Client OFF event log line (client):<literal/></para>

      <para><literal>23:00:00:723467 OFF flow&gt;1
      dst&gt;192.168.1.102/5000</literal></para>

      <para>Example Server OFF event log line (server):<literal/></para>

      <para><literal>23:00:00:723467 OFF
      src&gt;192.168.1.100/32423</literal></para>
    </sect2>

    <sect2 id="_Log_File_Start_Stop">
      <title>Log File START and STOP Events</title>

      <para>The format of the START and STOP event log file line
      is:<literal/></para>

      <para><literal>&lt;eventTime&gt;
      START</literal>or<literal>&lt;eventTime&gt;STOP</literal></para>

      <para>These log file lines indicate the time at which MGEN began and
      ended its operation. The "START" time corresponds to the relative time
      zero for any executed scripts. This "START" time is when the mgen
      program was executed unless the global <link
      linkend="_START">START</link> command was invoked. The "STOP" command
      corresponds to when the mgen program was halted.</para>
    </sect2>
  </sect1>

  <sect1 id="_Binary">
    <title>Binary Log File Format</title>

    <para>At the beginning of binary log files, there is a plain text line to
    make it easy to tell what kind of file it is. It has the RAPR version
    number, as well as the type of file ("binary_log"). This line is
    terminated with a line feed and a NULL ('\0') character. Following the
    NULL, the file contains a series of binary formatted records. There are
    several different types of records in the binary log file format. Each
    record consists of a number of fields. The first single-byte field
    indicates the record type. A record type of 0 is considered invalid. All
    multiple-byte fields are in standard network byte order (i.e. most
    significant byte first). Each record in the binary log file corresponds to
    a single unique RAPR event, just as each line in the text-based log file
    does. Each binary log file record contains the same information that every
    line of the text-format log file has. The text-format log file can
    actually be recreated from a binary log file using the "convert" command
    of RAPR.</para>

    <sect2 id="_Binary_Log_File_RECV_Events">
      <title>Binary Log File RECV Events</title>

      <programlisting>

The format of the RECV event binary log file record is:
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    type = 1   |   reserved    |       eventRecordLength       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       eventTimeSeconds                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     eventTimeMicroseconds                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            srcPort            |  srcAddrType  |  srcAddrLen   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          srcAddr ...                          |
                                                                 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          messageSize          |    version    |    flags      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          RAPRFlowId                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        sequenceNumber                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         txTimeSeconds                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       txTimeMicroseconds                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            dstPort            |  dstAddrType  |  dstAddrLen   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          dstAddr ...                          |
                                                                 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           hostPort            | hostAddrType  | hostAddrLen   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         hostAddr ...                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            latitude                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           longitude                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            altitude                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   gpsStatus   |  reserved   |           payloadLen            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          payload ...                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</programlisting>

      <para>The &lt;type&gt; field contains the record type. The record type
      for RECV events is 1. For backwards compatibility, unknown record types
      are skipped by the binary to text log file conversion function. The
      &lt;reserved&gt; field is unused at this time and is set to 0. The
      &lt;eventRecordLength&gt; field contains the length of this record,
      starting with the next byte. Thus, it contains the length of the entire
      record, less what will have already been read when this two-byte number
      is obtained. The &lt;srcPort&gt; field contains the port number that the
      message was sent from. The &lt;srcAddrType&gt; field indicates the type
      of the source. Possible types and values include:</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>INVALID_ADDRESS</entry>

              <entry>0</entry>
            </row>

            <row>
              <entry>IPv4</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>IPv6</entry>

              <entry>2</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The &lt;srcAddrLen&gt; field indicates the length in bytes of
      source address field &lt;srcAddr&gt; to follow. The length should be 0
      (zero) for the INVALID_ADDRESS type, 4 for IPv4 addresses, and 16 for
      IPv6 addresses. The &lt;srcAddr&gt; contains the address to which the
      RAPR message was sent from. The address is in network byte order. The
      rest of the packet is just a copy of the message payload from the
      original packet. For details on these fields, please look <link
      linkend="_RAPR_Message_Payload_1">here</link>.</para>
    </sect2>

    <sect2 id="Binary_Log_File_RERR_Event">
      <title>Binary Log File RERR Events</title>

      <para>The format of the RERR (receive error) event binary log file
      record is:</para>

      <programlisting>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    type = 1   |   reserved    |       eventRecordLength       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       eventTimeSeconds                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     eventTimeMicroseconds                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            srcPort            |  srcAddrType  |  srcAddrLen   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          srcAddr ...                          |
                                                                 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          errorType|                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</programlisting>

      <para>The &lt;type&gt; field contains the record type. The record type
      for RECV events is 1. For backwards compatibility, unknown record types
      are skipped by the binary to text log file conversion function. The
      &lt;reserved&gt; field is unused at this time and is set to 0. The
      &lt;eventRecordLength&gt; field contains the length of this record,
      starting with the next byte. Thus, it contains the length of the entire
      record, less what will have already been read when this two-byte number
      is obtained. The &lt;srcPort&gt; field contains the port number that the
      message was sent from. The &lt;srcAddrType&gt; field indicates the type
      of the source. Possible types and values include:</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>INVALID_ADDRESS</entry>

              <entry>0</entry>
            </row>

            <row>
              <entry>IPv4</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>IPv6</entry>

              <entry>2</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The &lt;srcAddrLen&gt; field indicates the length in bytes of
      source address field &lt;srcAddr&gt; to follow. The length should be 0
      (zero) for the INVALID_ADDRESS type, 4 for IPv4 addresses, and 16 for
      IPv6 addresses. The &lt;srcAddr&gt; contains the address to which the
      RAPR message was sent from. The address is in network byte order. The
      &lt;errorType&gt; indicates the type of message error detected and is
      one of the following possible error type values:</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>No error</entry>

              <entry>0</entry>
            </row>

            <row>
              <entry>Version number mismatch</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>Checksum validation failure</entry>

              <entry>2</entry>
            </row>

            <row>
              <entry>Message length error</entry>

              <entry>3</entry>
            </row>

            <row>
              <entry>Destination address invalid</entry>

              <entry>4</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2 id="Binary_Log_File_SEND_Events">
      <title>Binary Log File SEND Events</title>

      <para>SEND events are only logged if transmit logging has been turned on
      with the txlog option. The format of the SEND event binary log file
      record is:</para>

      <programlisting>
0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    type = 2   |   reserved    |       eventRecordLength       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          messageSize          |    version    |    flags      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          RAPRFlowId                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        sequenceNumber                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         txTimeSeconds                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       txTimeMicroseconds                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            dstPort            |  dstAddrType  |  dstAddrLen   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          dstAddr ...                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           hostPort            | hostAddrType  | hostAddrLen   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         hostAddr ...                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</programlisting>

      <para>These fields are the same ones that are used in the <link
      linkend="_Binary_Log_File_RECV%20Events">RECV</link> events. The
      &lt;type&gt; for SEND events is 2. Immediately following the
      &lt;eventRecordLength&gt; is a copy of the original message payload,
      without the GPS data and payload. The event time is left out, since it
      is the same as the transmit time.</para>
    </sect2>

    <sect2 id="Binary_Log_File_LISTEN_IGNORE_Events">
      <title>Binary Log File LISTEN/IGNORE Events</title>

      <para>LISTEN and IGNORE events both have the same format:</para>

      <programlisting>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  type = 3/4   |   reserved    |       eventRecordLength       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       eventTimeSeconds                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     eventTimeMicroseconds                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   protocol    |   reserved    |          portNumber           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</programlisting>

      <para>LISTEN events have a &lt;type&gt; of 3, while IGNORE events have a
      &lt;type&gt; of 4. The &lt;protocol&gt; field contains the transport
      protocol type to LISTEN for, while the &lt;portNumber&gt; field tells us
      what port number to LISTEN on. Possible types and values for the
      &lt;protocol&gt; include:</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>INVALID_PROTOCOL</entry>

              <entry>0</entry>
            </row>

            <row>
              <entry>UDP</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>TCP (unsupported)</entry>

              <entry>2</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2 id="Binary_Log_File_JOIN_LEAVE_Events">
      <title>Binary Log File JOIN/LEAVE Events</title>

      <para>JOIN and LEAVE events also have an identical format:</para>

      <programlisting>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  type = 5/6   |   reserved    |       eventRecordLength       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       eventTimeSeconds                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     eventTimeMicroseconds                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           groupPort           | groupAddrType | groupAddrLen  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         groupAddr ...                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| ifaceNameLen  |             asciiInterfaceName ...            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     asciiInterfaceName ...                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</programlisting>

      <para>JOIN events are of &lt;type&gt; 5, and LEAVE events have a
      &lt;type&gt; of 6. The &lt;groupPort&gt; is the port which will be used
      to JOIN/LEAVE the group. The &lt;groupAddrType&gt;,
      &lt;groupAddrLen&gt;, and &lt;groupAddr&gt; are the type, length, and
      raw value of the group address, similar to those of addresses in other
      record types. The ifaceNameLen field contains the length in bytes of the
      &lt;asciiInterfaceName&gt; that follows it.</para>
    </sect2>

    <sect2 id="Binary_Log_File_START_STOP_Events">
      <title>Binary Log File START/STOP Events</title>

      <para>START and STOP events both have the same format:</para>

      <programlisting>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  type = 7/8   |   reserved    |       eventRecordLength       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       eventTimeSeconds                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     eventTimeMicroseconds                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</programlisting>

      <para>START events have a &lt;type&gt; 7, while STOP events are of
      &lt;type&gt; 8. They contain only the time the event occurred.</para>
    </sect2>
  </sect1>

  <sect1 id="_RAPR_Message_Payload_">
     

    <title>RAPR Message Payload</title>

     The RAPR message payload format is given below. Note that the Version 4.1 message format is slightly different than that of RAPR Version 4.0. The RAPR message payload is in the following format: 

    <programlisting>
 0                   1                   2                   3 
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          messageSize          |    version    |    flags      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          RAPRFlowId                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        sequenceNumber                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         txTimeSeconds                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       txTimeMicroseconds                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            dstPort            |  dstAddrType  |  dstAddrLen   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          dstAddr ...                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           hostPort            | hostAddrType  | hostAddrLen   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         hostAddr ...                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            latitude                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           longitude                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            altitude                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   gpsStatus   |  reserved   |           payloadLen            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          payload ...                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           padding                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          checksum                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</programlisting>

     All multiple-byte fields are in standard network byte order (i.e. most significant byte first). The &lt;messageSize&gt; field indicates the total size (including the &lt;messageSize&gt;, &lt;version&gt;, &lt;flags&gt;, etc fields) of the RAPR message in bytes. The current UDP-only transport limits this to a maximum of 8192 bytes. In the future, larger message sizes will be supported and in conjunction with the &lt;flags&gt; field, very large messages will be supported as a concatenation of RAPR messages to support emulation of large file transfers, etc. 

    <para>The &lt;version&gt; field is the RAPR message protocol version
    number. This will enable future versions of RAPR to b backwards compatible
    and prevent older versions of RAPR from attempting to parse packets in
    unknown format. Currently a single &lt;flags&gt; value (CHECKSUM = 0x01)
    is defined. When this flag is set, it indicates the presence of the
    &lt;checksum&gt; field at the end of the RAPR message. It is expected that
    additional flags will be useful as RAPR adds support for transport types
    besides UDP.</para>

     

    <para>The &lt;RAPRFlowId&gt; contains the flow/thread identification value
    associated with the RAPR flow in the corresponding script which created
    the flow. Note that each flow identified from an RAPR source has its own
    sequence number space.</para>

     

    <para>The &lt;sequenceNumber&gt; contains the 32-bit sequence number which
    is incremented with each message generated for an RAPR flow. This will
    wrap to zero when the maximum is reached.</para>

     

    <para>The &lt;txTimeSeconds&gt; and &lt;txTimeMicroseconds&gt; fields are
    used to mark the time of transmission of the RAPR message. The time is the
    source computer's system time in Greenwich Mean Time (GMT).</para>

     

    <para>The &lt;dstPort&gt; is the destination port number to which the RAPR
    message addressed by the source. The &lt;dstAddrType&gt; field indicates
    the type of destination address encapsulated in following fields. Possible
    types and values include:</para>

     

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>INVALID_ADDRESS</entry>

            <entry>0</entry>
          </row>

          <row>
            <entry>IPv4</entry>

            <entry>1</entry>
          </row>

          <row>
            <entry>IPv6</entry>

            <entry>2</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

     The &lt;dstAddrLen&gt; field indicates the length in bytes of the destination address field &lt;dstAddr&gt; to follow. The length should be 0 (zero) for the INVALID_ADDRESS type, 4 for IPv4 addresses, and 16 f or IPv6 addresses. 

    <para>The &lt;dstAddr&gt; contains the destination address to which the
    source addressed the RAPR message. The address is in network byte order.
    Note that the following fields are optional and the RAPR message length my
    be truncated at any point after here. Any incomplete optional fields are
    considered invalid.</para>

     

    <para>The &lt;hostPort&gt; and &lt;hostAddr&gt; (if present and valid)
    contain the RAPR message source's default local address. Note that this
    may be different from the source address contained in the RAPR log file
    due to firewalls, Network Address Translation (NAT) devices, multi-homed
    sources, etc.</para>

     

    <para>The &lt;hostPort&gt; is the destination port number to which the
    RAPR message was addressed by the source. The &lt;hostAddrType&gt; field
    indicates the type of destination address encapsulated in following
    fields. The possible values are the same as for the &lt;dstAddrType&gt;
    described above. The &lt;hostAddrLen&gt; field indicates the length in
    bytes of the destination address field &lt;hostAddr&gt; to follow. The
    &lt;hostAddr&gt; contains the source's perception of its local default
    network address. In RAPR, this is determined by a system call to
    gethostname(), followed by a call to name resolution. This address may be
    incorrect if the host is not correctly configured or domain name service
    (DNS) is unavailable.</para>

     

    <para>The &lt;latitude&gt;, &lt;longitude&gt;, and &lt;altitude&gt; fields
    contain values corresponding to GPS information for the RAPR source if it
    was available. The &lt;latitude&gt; and &lt;longitude&gt; fields are
    encoded as follows: &lt;fieldValue&gt; = (unsigned
    long)((&lt;actualValue&gt;+180.0)*60000.0) The &lt;altitude&gt; field is
    the direct representation of the altitude value available from the
    source's GPS system. The &lt;gpsStatus&gt; indicates the validity of the
    GPS information which was encoded. Possible status types and values
    currently include:</para>

     

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>INVALID_GPS</entry>

            <entry>0</entry>
          </row>

          <row>
            <entry>STALE</entry>

            <entry>1</entry>
          </row>

          <row>
            <entry>CURRENT</entry>

            <entry>2</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

     

    <para>In addition to the &lt;gpsStatus&gt; field, actual values of 999.0
    for latitude and longitude, and Ð999 for altitude also correspond to
    invalid values. The &lt;payloadLen&gt; field, when of non-zero value,
    indicates the presence of optional user-defined content in the RAPR
    message. The &lt;payloadLen&gt; value indicates the quantity (in bytes) of
    user-defined content which follows. The &lt;payload&gt; field may contain
    some RAPR specific directives like the triggering behavior event's UBI for
    interrogative objects, random seed, any payload logic ID, etc. RAPR
    specific payload content will be displayed in hex avlues in the log files
    as:</para>

     

    <programlisting>
Example RAPR payload with two fields:
DATA [0204020000000304BF6A2837]

First field: 020402000000
02: Rapr Field type indicator
04: Rapr Field length
02000000: Rapr Field Value

Second Field: 0304BF6A2837
03: Rapr Field type indicator
04: Rapr Field length
BF6A2837: Rapr Field Value
</programlisting>

     

    <para>The hex field indicators can be translated as follows:</para>

     

    <itemizedlist>
      <listitem>01 RAPR UBI</listitem>

      <listitem>02 RAPR Payload Logic ID</listitem>

      <listitem>03 RAPR Seed</listitem>

      <listitem>04 RAPR Foriegn UBI</listitem>

      <listitem>05 RAPR StreamID</listitem>

      <listitem>06 RAPR Stream Sequence Number</listitem>

      <listitem>07 RAPR Stream Duration</listitem>

      <listitem>08 RAPR Stream Burst Count</listitem>

      <listitem>09 RAPR Stream Burst Payload ID</listitem>

      <listitem>0A RAPR Stream Burst Priority</listitem>
    </itemizedlist>

     

    <para>In general, all RAPR messages will contain at least a seed value.
    The &lt;payload&gt; field also may contain user-defined content and is of
    length &lt;payloadLen&gt; bytes. Note that a short RAPR
    &lt;messageSize&gt; could truncate this field. If the RAPR user provides
    the optional user-defined content, it is up to the user to ensure that the
    generated RAPR messages are of sufficient size as not to truncate the
    &lt;payload&gt; content. The &lt;padding&gt; portion of RAPR messages
    contain undefined data content.</para>

     

    <para>The &lt;checksum&gt; field is optional and is present when the
    CHECKSUM (0x01) flag is set in the &lt;flags&gt; field. Note that
    corrupted messages may result in RAPR messages with the &lt;flags&gt;
    field itself corrupted, so it may be useful for RAPR implementations to
    have an option to validate checksums even when the CHECKSUM flag is not
    set if it is known that the sender is providing checksum content.</para>

     

    <para>Note: The total size of the RAPR message is defined by the
    &lt;messageSize&gt; field. The optional fields may be truncated if the
    &lt;messageSize&gt; is small. The minimum RAPR message size will depend
    upon the IP address types being used. For example, the minimum allowed
    RAPR message size using IPv4 addresses with no optional fields is 28 bytes
    (i.e. for UDP, the UDP payload size would be 28 bytes). If GPS information
    is to be included without truncation, the minimum message size becomes 52
    bytes with the inclusion of the &lt;hostAddr&gt; and GPS information. For
    IPv6 destination addresses, the minimum allowed RAPR message size is 40
    bytes with no optional fields. If GPS information is included the minimum
    message size with truncating information is 76 bytes.</para>

     
  </sect1>

  <sect1>
    <title>Known Bugs and Issues</title>

    <sect2>
      <title>Offset and the Periodic Object</title>

      <para>Using the OFFSET command with the PERIODIC object may interfere
      with the repeatability of the object's behavior during multiple scenario
      runs if the offset start time overlaps with the duration of the periodic
      object. Periodic objects that complete or begin before or after the
      offset time will not be affected. When the periods overlap, the seeding
      of spawned behavior events will not be correct, and therefore
      repeatable.</para>
    </sect2>

    <sect2>
      <title>POISSON (Exponential) MGEN Patterns and Repeatability</title>

      <para>Currently MGEN does not use a parallel random number generator and
      therefore MGEN patterns that make random number draws (e.g. the POISSON
      pattern, the EXP pattern, etc.) will not be repeatable.</para>
    </sect2>

    <sect2>
      <title>RAPR and SMF</title>

      <para>In environments where UDP packet duplication is possible (such as
      when running SMF) care should be taken when triggering logic behavior.
      For example, each Declarative message will trigger a behavior response
      and as such duplicated packets will trigger duplicate behaviors.. In
      general in such environments, triggering behavior should be restricted
      to interrogative TCP messages.</para>

      <para>Note also that Stream Behavior Events cannot be reliably used in
      highly volatile mobile environments as loss of a network connectivity
      with a single participant may end the behavior.</para>
    </sect2>

    <sect2>
      <title>Path Specification </title>

      <para>Paths must be fully qualified in RAPR at present. (e.g. relative
      paths not supported). Some techniques desribed in the best practices
      section may help address this limitation.</para>
    </sect2>

    <sect2>
      <title>Stream Behavior Events and Network Volatility</title>

      <para>Stream behavior events do not perform well in environments with
      high network volatility as loss of a single participant may end the
      behavior. Note that network lossiness is tolerated as a single message
      in a stream is all that is required to continute the
      "interaction".</para>
    </sect2>
  </sect1>
</article>
